{"version":3,"file":"masonic.js","sources":["../../node_modules/@react-hook/window-size/node_modules/@react-hook/event/src/index.tsx","../../node_modules/@react-hook/throttle/src/index.tsx","../../node_modules/@react-hook/throttle/node_modules/@react-hook/latest/src/index.tsx","../../node_modules/@react-hook/window-scroll/node_modules/@react-hook/event/src/index.tsx","../../src/use-scroller.ts","../../node_modules/@react-hook/window-scroll/src/index.tsx","../../node_modules/@essentials/request-timeout/src/index.ts","../../src/use-force-update.ts","../../src/use-masonry.tsx","../../src/masonry-scroller.tsx","../../src/use-container-position.ts","../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","../../src/use-resize-observer.ts","../../src/interval-tree.ts","../../src/use-positioner.ts","../../src/use-scroll-to-index.ts","../../node_modules/@react-hook/event/src/index.tsx","../../src/masonry.tsx","../../node_modules/@react-hook/window-size/src/index.tsx","../../node_modules/@react-hook/debounce/src/index.tsx","../../node_modules/@react-hook/debounce/node_modules/@react-hook/latest/src/index.tsx","../../node_modules/@react-hook/passive-layout-effect/src/index.tsx","../../node_modules/@react-hook/window-size/node_modules/@react-hook/latest/src/index.tsx","../../node_modules/@react-hook/window-scroll/node_modules/@react-hook/latest/src/index.tsx","../../node_modules/@essentials/raf/src/index.ts","../../node_modules/trie-memoize/src/index.ts","../../node_modules/@essentials/one-key-map/src/index.ts","../../node_modules/@essentials/memoize-one/src/index.ts","../../node_modules/@react-hook/latest/src/index.tsx","../../src/elements-cache.ts","../../node_modules/raf-schd/dist/raf-schd.esm.js","../../node_modules/@react-hook/event/node_modules/@react-hook/latest/src/index.tsx","../../src/use-infinite-loader.ts","../../src/list.tsx"],"sourcesContent":["import * as React from 'react'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\nimport useLatest from '@react-hook/latest'\n\nfunction useEvent<\n  T extends Window = Window,\n  K extends keyof WindowEventMap = keyof WindowEventMap\n>(\n  target: Window | null,\n  type: K,\n  listener: WindowEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends Document = Document,\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n>(\n  target: Document | null,\n  type: K,\n  listener: DocumentEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends HTMLElement = HTMLElement,\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n>(\n  target: React.RefObject<T> | T | null,\n  type: K,\n  listener: ElementEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent(\n  target: any,\n  type: any,\n  listener: any,\n  cleanup: any = noop\n): void {\n  const storedListener = useLatest(listener)\n  const storedCleanup = useLatest(cleanup)\n\n  useLayoutEffect(() => {\n    const targetEl = target && 'current' in target ? target.current : target\n    if (!targetEl) return\n\n    const listener = function (this: any, ...args: any[]) {\n      storedListener.current.apply(this, args)\n    }\n\n    targetEl.addEventListener(type, listener)\n    const cleanup = storedCleanup.current\n\n    return () => {\n      targetEl.removeEventListener(type, listener)\n      cleanup()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, type])\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nexport type ElementEventListener<\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n> = (this: HTMLElement, ev: HTMLElementEventMap[K]) => any\n\nexport type DocumentEventListener<\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n> = (this: Document, ev: DocumentEventMap[K]) => any\n\nexport type WindowEventListener<\n  K extends keyof WindowEventMap = keyof WindowEventMap\n> = (this: Document, ev: WindowEventMap[K]) => any\n\nexport default useEvent\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\nconst perf = typeof performance !== 'undefined' ? performance : Date\nconst now = () => perf.now()\n\nexport function useThrottleCallback<CallbackArguments extends any[]>(\n  callback: (...args: CallbackArguments) => void,\n  fps = 30,\n  leading = false\n): (...args: CallbackArguments) => void {\n  const storedCallback = useLatest(callback)\n  const ms = 1000 / fps\n  const prev = React.useRef(0)\n  const trailingTimeout = React.useRef<ReturnType<typeof setTimeout>>()\n  const clearTrailing = () =>\n    trailingTimeout.current && clearTimeout(trailingTimeout.current)\n  const deps = [fps, leading, storedCallback]\n\n  // Reset any time the deps change\n  React.useEffect(\n    () => () => {\n      prev.current = 0\n      clearTrailing()\n    },\n    deps\n  )\n\n  return React.useCallback(function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args = arguments\n    const rightNow = now()\n    const call = () => {\n      prev.current = rightNow\n      clearTrailing()\n      storedCallback.current.apply(null, args as any)\n    }\n    const current = prev.current\n    // leading\n    if (leading && current === 0) return call()\n    // body\n    if (rightNow - current > ms) {\n      if (current > 0) return call()\n      prev.current = rightNow\n    }\n    // trailing\n    clearTrailing()\n    trailingTimeout.current = setTimeout(() => {\n      call()\n      prev.current = 0\n    }, ms)\n  }, deps)\n}\n\nexport function useThrottle<State>(\n  initialState: State | (() => State),\n  fps?: number,\n  leading?: boolean\n): [State, React.Dispatch<React.SetStateAction<State>>] {\n  const state = React.useState<State>(initialState)\n  return [state[0], useThrottleCallback(state[1], fps, leading)]\n}\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  storedValue.current = current\n  return storedValue\n}\n\nexport default useLatest\n","import * as React from 'react'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\nimport useLatest from '@react-hook/latest'\n\nfunction useEvent<\n  T extends Window = Window,\n  K extends keyof WindowEventMap = keyof WindowEventMap\n>(\n  target: Window | null,\n  type: K,\n  listener: WindowEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends Document = Document,\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n>(\n  target: Document | null,\n  type: K,\n  listener: DocumentEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends HTMLElement = HTMLElement,\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n>(\n  target: React.RefObject<T> | T | null,\n  type: K,\n  listener: ElementEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent(\n  target: any,\n  type: any,\n  listener: any,\n  cleanup: any = noop\n): void {\n  const storedListener = useLatest(listener)\n  const storedCleanup = useLatest(cleanup)\n\n  useLayoutEffect(() => {\n    const targetEl = target && 'current' in target ? target.current : target\n    if (!targetEl) return\n\n    const listener = function (this: any, ...args: any[]) {\n      storedListener.current.apply(this, args)\n    }\n\n    targetEl.addEventListener(type, listener)\n    const cleanup = storedCleanup.current\n\n    return () => {\n      targetEl.removeEventListener(type, listener)\n      cleanup()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, type])\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nexport type ElementEventListener<\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n> = (this: HTMLElement, ev: HTMLElementEventMap[K]) => any\n\nexport type DocumentEventListener<\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n> = (this: Document, ev: DocumentEventMap[K]) => any\n\nexport type WindowEventListener<\n  K extends keyof WindowEventMap = keyof WindowEventMap\n> = (this: Document, ev: WindowEventMap[K]) => any\n\nexport default useEvent\n","import * as React from 'react'\nimport useScrollPosition from '@react-hook/window-scroll'\nimport {requestTimeout, clearRequestTimeout} from '@essentials/request-timeout'\n\n/**\n * A hook for tracking whether the `window` is currently being scrolled and it's scroll position on\n * the y-axis. These values are used for determining which grid cells to render and when\n * to add styles to the masonry container that maximize scroll performance.\n *\n * @param offset The vertical space in pixels between the top of the grid container and the top\n *  of the browser `document.documentElement`.\n * @param fps This determines how often (in frames per second) to update the scroll position of the\n *  browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n *  The default value of `12` has been very reasonable in my own testing, but if you have particularly\n *  heavy `render` components it may be prudent to reduce this number.\n */\nexport function useScroller(\n  offset = 0,\n  fps = 12\n): {scrollTop: number; isScrolling: boolean} {\n  const scrollTop = useScrollPosition(fps)\n  const [isScrolling, setIsScrolling] = React.useState(false)\n  const didMount = React.useRef(0)\n\n  React.useEffect(() => {\n    if (didMount.current === 1) setIsScrolling(true)\n    const to = requestTimeout(() => {\n      // This is here to prevent premature bail outs while maintaining high resolution\n      // unsets. Without it there will always bee a lot of unnecessary DOM writes to style.\n      setIsScrolling(false)\n    }, 40 + 1000 / fps)\n    didMount.current = 1\n    return () => clearRequestTimeout(to)\n  }, [fps, scrollTop])\n\n  return {scrollTop: Math.max(0, scrollTop - offset), isScrolling}\n}\n","import {useThrottle} from '@react-hook/throttle'\nimport useEvent from '@react-hook/event'\n\nconst win = typeof window === 'undefined' ? null : window\nconst getScrollY = (): number =>\n  (win as Window).scrollY !== void 0\n    ? (win as Window).scrollY\n    : (win as Window).pageYOffset === void 0\n    ? 0\n    : (win as Window).pageYOffset\n\nexport const useWindowScroll = (fps = 30): number => {\n  const state = useThrottle(\n    typeof window === 'undefined' ? 0 : getScrollY,\n    fps,\n    true\n  )\n  useEvent(win, 'scroll', (): void => state[1](getScrollY()))\n  return state[0]\n}\n\nexport default useWindowScroll\n","/**\n * Copyright 2011, Joe Lambert.\n * Free to use under the MIT license.\n * http://www.opensource.org/licenses/mit-license.php\n **/\nimport {raf, caf, now} from '@essentials/raf'\n\nexport interface RequestTimeoutHandle {\n  v?: number\n}\n\nexport const clearRequestTimeout = (handle: RequestTimeoutHandle): void => {\n  caf(handle.v || -1)\n}\n\nexport const requestTimeout = (\n  fn: (...args: any[]) => void,\n  ms: number\n): RequestTimeoutHandle => {\n  const start = now(),\n    handle: RequestTimeoutHandle = {}\n\n  const loop = () => {\n    now() - start >= ms ? fn.call(null) : (handle.v = raf(loop))\n  }\n\n  handle.v = raf(loop)\n  return handle\n}\n\nexport default requestTimeout\n","import * as React from 'react'\n\nexport function useForceUpdate() {\n  const setState = React.useState(emptyObj)[1]\n  return React.useRef(() => setState({})).current\n}\n\nconst emptyObj = {}\n","import * as React from 'react'\nimport trieMemoize from 'trie-memoize'\nimport OneKeyMap from '@essentials/one-key-map'\nimport memoizeOne from '@essentials/memoize-one'\nimport useLatest from '@react-hook/latest'\nimport {elementsCache} from './elements-cache'\nimport {useForceUpdate} from './use-force-update'\nimport {Positioner} from './use-positioner'\n\n/**\n * This hook handles the render phases of the masonry layout and returns the grid as a React element.\n *\n * @param options Options for configuring the masonry layout renderer. See `UseMasonryOptions`.\n */\nexport function useMasonry<Item> ({\n  // Measurement and layout\n  positioner,\n  resizeObserver,\n  // Grid items\n  items,\n  // Container props\n  as: ContainerComponent = 'div',\n  id,\n  key,\n  className,\n  style,\n  role = 'grid',\n  tabIndex = 0,\n  containerRef,\n  // Item props\n  itemAs: ItemComponent = 'div',\n  itemStyle,\n  itemHeightEstimate = 300,\n  itemKey = defaultGetItemKey,\n  // Rendering props\n  overscanBy = 2,\n  scrollTop,\n  isScrolling,\n  height,\n  render: RenderComponent,\n  onRender\n}: UseMasonryOptions<Item>) {\n  let startIndex = 0\n  let stopIndex: number | undefined\n  const forceUpdate = useForceUpdate()\n  const setItemRef = getRefSetter(positioner, resizeObserver)\n  const itemCount = items.length\n  const {\n    columnWidth,\n    columnCount,\n    range,\n    estimateHeight,\n    size,\n    shortestColumn\n  } = positioner\n  const measuredCount = size()\n  const shortestColumnSize = shortestColumn()\n  const children: React.ReactElement[] = []\n  const itemRole =\n    role === 'list' ? 'listitem' : role === 'grid' ? 'gridcell' : undefined\n  const storedOnRender = useLatest(onRender)\n\n  overscanBy = height * overscanBy\n  const rangeEnd = scrollTop + overscanBy\n  const needsFreshBatch =\n    shortestColumnSize < rangeEnd && measuredCount < itemCount\n\n  range(\n    // We overscan in both directions because users scroll both ways,\n    // though one must admit scrolling down is more common and thus\n    // we only overscan by half the downward overscan amount\n    Math.max(0, scrollTop - overscanBy / 2),\n    rangeEnd,\n    (index, left, top) => {\n      const data = items[index]\n      const key = itemKey(data, index)\n      const phaseTwoStyle: React.CSSProperties = {\n        top,\n        left,\n        width: columnWidth,\n        writingMode: 'horizontal-tb',\n        position: 'absolute'\n      }\n\n      /* istanbul ignore next */\n      if (\n        typeof process !== 'undefined' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        throwWithoutData(data, index)\n      }\n\n      children.push(\n        <ItemComponent\n          key={key}\n          ref={setItemRef(index)}\n          role={itemRole}\n          style={\n            typeof itemStyle === 'object' && itemStyle !== null\n              ? Object.assign({}, phaseTwoStyle, itemStyle)\n              : phaseTwoStyle\n          }\n        >\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\n        </ItemComponent>\n      )\n\n      if (stopIndex === void 0) {\n        startIndex = index\n        stopIndex = index\n      } else {\n        startIndex = Math.min(startIndex, index)\n        stopIndex = Math.max(stopIndex, index)\n      }\n    }\n  )\n\n  if (needsFreshBatch) {\n    const batchSize = Math.min(\n      itemCount - measuredCount,\n      Math.ceil(\n        ((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate) *\n          columnCount\n      )\n    )\n\n    let index = measuredCount\n    const phaseOneStyle = getCachedSize(columnWidth)\n\n    for (; index < measuredCount + batchSize; index++) {\n      const data = items[index]\n      const key = itemKey(data, index)\n\n      /* istanbul ignore next */\n      if (\n        typeof process !== 'undefined' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        throwWithoutData(data, index)\n      }\n\n      children.push(\n        <ItemComponent\n          key={key}\n          ref={setItemRef(index)}\n          role={itemRole}\n          style={\n            typeof itemStyle === 'object'\n              ? Object.assign({}, phaseOneStyle, itemStyle)\n              : phaseOneStyle\n          }\n        >\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\n        </ItemComponent>\n      )\n    }\n  }\n\n  // Calls the onRender callback if the rendered indices changed\n  React.useEffect(() => {\n    if (typeof storedOnRender.current === 'function' && stopIndex !== void 0)\n      storedOnRender.current(startIndex, stopIndex, items)\n\n    didEverMount = '1'\n  }, [startIndex, stopIndex, items, storedOnRender])\n  // If we needed a fresh batch we should reload our components with the measured\n  // sizes\n  React.useEffect(() => {\n    if (needsFreshBatch) forceUpdate()\n    // eslint-disable-next-line\n  }, [needsFreshBatch])\n\n  // gets the container style object based upon the estimated height and whether or not\n  // the page is being scrolled\n  const containerStyle = getContainerStyle(\n    isScrolling,\n    estimateHeight(itemCount, itemHeightEstimate)\n  )\n\n  return (\n    <ContainerComponent\n      ref={containerRef}\n      key={`${key || ''}-${didEverMount}`}\n      id={id}\n      role={role}\n      className={className}\n      tabIndex={tabIndex}\n      style={\n        typeof style === 'object'\n          ? assignUserStyle(containerStyle, style)\n          : containerStyle\n      }\n      children={children}\n    />\n  )\n}\n\n/* istanbul ignore next */\nfunction throwWithoutData (data: any, index: number) {\n  if (!data) {\n    throw new Error(\n      `No data was found at index: ${index}\\n\\n` +\n        `This usually happens when you've mutated or changed the \"items\" array in a ` +\n        `way that makes it shorter than the previous \"items\" array. Masonic knows nothing ` +\n        `about your underlying data and when it caches cell positions, it assumes you aren't ` +\n        `mutating the underlying \"items\".\\n\\n` +\n        `See https://codesandbox.io/s/masonic-w-react-router-example-2b5f9?file=/src/index.js for ` +\n        `an example that gets around this limitations. For advanced implementations, see ` +\n        `https://codesandbox.io/s/masonic-w-react-router-and-advanced-config-example-8em42?file=/src/index.js\\n\\n` +\n        `If this was the result of your removing an item from your \"items\", see this issue: ` +\n        `https://github.com/jaredLunde/masonic/issues/12`\n    )\n  }\n}\n\n// This is for triggering a remount after SSR has loaded in the client w/ hydrate()\nlet didEverMount = '0'\n\nexport interface UseMasonryOptions<Item> {\n  /**\n   * An array containing the data used by the grid items.\n   */\n  items: Item[]\n  /**\n   * A grid cell positioner and cache created by the `usePositioner()` hook or\n   * the `createPositioner` utility.\n   */\n  positioner: Positioner\n  /**\n   * A resize observer that tracks mutations to the grid cells and forces the\n   * Masonry grid to recalculate its layout if any cells affect column heights\n   * change. Check out the `useResizeObserver()` hook.\n   */\n  resizeObserver?: {\n    observe: ResizeObserver['observe']\n    disconnect: ResizeObserver['observe']\n    unobserve: ResizeObserver['unobserve']\n  }\n  /**\n   * This is the type of element the grid container will be rendered as.\n   * @default \"div\"`\n   */\n  as?: keyof JSX.IntrinsicElements | React.ComponentType<any>\n  /**\n   * Optionally gives the grid container an `id` prop.\n   */\n  id?: string\n  /**\n   * Prefix to key used for forcing re-renders\n   */\n  key?: string\n  /**\n   * Optionally gives the grid container a `className` prop.\n   */\n  className?: string\n  /**\n   * Adds extra `style` attributes to the container in addition to those\n   * created by the `useMasonry()` hook.\n   */\n  style?: React.CSSProperties\n  /**\n   * Optionally swap out the accessibility `role` prop of the container and its items.\n   * @default \"grid\"\n   */\n  role?: 'grid' | 'list'\n  /**\n   * Change the `tabIndex` of the grid container.\n   * @default 0\n   */\n  tabIndex?: number\n  /**\n   * Forwards a React ref to the grid container.\n   */\n  containerRef?:\n    | ((element: HTMLElement) => void)\n    | React.MutableRefObject<HTMLElement | null>\n  /**\n   * This is the type of element the grid items will be rendered as.\n   * @default \"div\"\n   */\n  itemAs?: keyof JSX.IntrinsicElements | React.ComponentType<any>\n  /**\n   * Adds extra `style` attributes to the grid items in addition to those\n   * created by the `useMasonry()` hook.\n   */\n  itemStyle?: React.CSSProperties\n  /**\n   * This value is used for estimating the initial height of the masonry grid. It is important for\n   * the UX of the scrolling behavior and in determining how many `items` to render in a batch, so it's\n   * wise to set this value with some level accuracy, though it doesn't need to be perfect.\n   * @default 300\n   */\n  itemHeightEstimate?: number\n  /**\n   * The value returned here must be unique to the item. By default, the key is the item's index. This is ok\n   * if your collection of items is never modified. Setting this property ensures that the component in `render`\n   * is reused each time the masonry grid is reflowed. A common pattern would be to return the item's database\n   * ID here if there is one, e.g. `data => data.id`\n   * @default (data, index) => index`\n   */\n  itemKey?: (data: Item, index: number) => string | number\n  /**\n   * This number is used for determining the number of grid cells outside of the visible window to render.\n   * The default value is `2` which means \"render 2 windows worth (2 * `height`) of content before and after\n   * the items in the visible window\". A value of `3` would be 3 windows worth of grid cells, so it's a\n   * linear relationship.\n   *\n   * Overscanning is important for preventing tearing when scrolling through items in the grid, but setting\n   * too high of a vaimport { useForceUpdate } from './use-force-update';\nlue may create too much work for React to handle, so it's best that you tune this\n   * value accordingly.\n   * @default 2\n   */\n  overscanBy?: number\n\n  /**\n   * This is the height of the window. If you're rendering the grid relative to the browser `window`,\n   * the current `document.documentElement.clientHeight` is the value you'll want to set here. If you're\n   * rendering the grid inside of another HTML element, you'll want to provide the current `element.offsetHeight`\n   * here.\n   */\n  height: number\n  /**\n   * The current scroll progress in pixel of the window the grid is rendered in. If you're rendering\n   * the grid relative to the browser `window`, you'll want the most current `window.scrollY` here.\n   * If you're rendering the grid inside of another HTML element, you'll want the current `element.scrollTop`\n   * value here. The `useScroller()` hook and `<MasonryScroller>` components will help you if you're\n   * rendering the grid relative to the browser `window`.\n   */\n  scrollTop: number\n  /**\n   * This property is used for determining whether or not the grid container should add styles that\n   * dramatically increase scroll performance. That is, turning off `pointer-events` and adding a\n   * `will-change: contents;` value to the style string. You can forgo using this prop, but I would\n   * not recommend that. The `useScroller()` hook and `<MasonryScroller>` components will help you if\n   * you're rendering the grid relative to the browser `window`.\n   * @default false\n   */\n  isScrolling?: boolean\n  /**\n   * This component is rendered for each item of your `items` prop array. It should accept three props:\n   * `index`, `width`, and `data`. See RenderComponentProps.\n   */\n  render: React.ComponentType<RenderComponentProps<Item>>\n  /**\n   * This callback is invoked any time the items currently being rendered by the grid change.\n   */\n  onRender?: (startIndex: number, stopIndex: number, items: Item[]) => void\n}\n\nexport interface RenderComponentProps<Item> {\n  /**\n   * The index of the cell in the `items` prop array.\n   */\n  index: number\n  /**\n   * The rendered width of the cell's column.\n   */\n  width: number\n  /**\n   * The data at `items[index]` of your `items` prop array.\n   */\n  data: Item\n}\n\n//\n// Render-phase utilities\n\n// ~5.5x faster than createElement without the memo\nconst createRenderElement = trieMemoize(\n  [OneKeyMap, {}, WeakMap, OneKeyMap],\n  (RenderComponent, index, data, columnWidth) => (\n    <RenderComponent index={index} data={data} width={columnWidth} />\n  )\n)\n\nconst getContainerStyle = memoizeOne(\n  (isScrolling: boolean | undefined, estimateHeight: number) => ({\n    position: 'relative',\n    width: '100%',\n    maxWidth: '100%',\n    height: Math.ceil(estimateHeight),\n    maxHeight: Math.ceil(estimateHeight),\n    willChange: isScrolling ? 'contents' : void 0,\n    pointerEvents: isScrolling ? 'none' : void 0\n  })\n)\n\nconst cmp2 = (args: IArguments, pargs: IArguments | any[]): boolean =>\n  args[0] === pargs[0] && args[1] === pargs[1]\n\nconst assignUserStyle = memoizeOne(\n  (containerStyle, userStyle) => Object.assign({}, containerStyle, userStyle),\n  // @ts-ignore\n  cmp2\n)\n\nfunction defaultGetItemKey<Item> (_: Item, i: number) {\n  return i\n}\n\n// the below memoizations for for ensuring shallow equal is reliable for pure\n// component children\nconst getCachedSize = memoizeOne(\n  (width: number): React.CSSProperties => ({\n    width,\n    zIndex: -1000,\n    visibility: 'hidden',\n    position: 'absolute',\n    writingMode: 'horizontal-tb'\n  }),\n  (args, pargs) => args[0] === pargs[0]\n)\n\nconst getRefSetter = memoizeOne(\n  (\n    positioner: Positioner,\n    resizeObserver?: UseMasonryOptions<any>['resizeObserver']\n  ) => (index: number) => (el: HTMLElement | null): void => {\n    if (el === null) return\n    if (resizeObserver) {\n      resizeObserver.observe(el)\n      elementsCache.set(el, index)\n    }\n    if (positioner.get(index) === void 0) positioner.set(index, el.offsetHeight)\n  },\n  // @ts-ignore\n  cmp2\n)\n","import {useScroller} from './use-scroller'\nimport {useMasonry} from './use-masonry'\nimport type {UseMasonryOptions} from './use-masonry'\n/**\n * A heavily-optimized component that updates `useMasonry()` when the scroll position of the browser `window`\n * changes. This bare-metal component is used by `<Masonry>` under the hood.\n */\nexport function MasonryScroller<Item>(props: MasonryScrollerProps<Item>) {\n  // We put this in its own layer because it's the thing that will trigger the most updates\n  // and we don't want to slower ourselves by cycling through all the functions, objects, and effects\n  // of other hooks\n  const {scrollTop, isScrolling} = useScroller(props.offset, props.scrollFps)\n  // This is an update-heavy phase and while we could just Object.assign here,\n  // it is way faster to inline and there's a relatively low hit to he bundle\n  // size.\n  return useMasonry<Item>({\n    scrollTop,\n    isScrolling,\n    positioner: props.positioner,\n    resizeObserver: props.resizeObserver,\n    items: props.items,\n    onRender: props.onRender,\n    as: props.as,\n    id: props.id,\n    className: props.className,\n    style: props.style,\n    role: props.role,\n    tabIndex: props.tabIndex,\n    containerRef: props.containerRef,\n    itemAs: props.itemAs,\n    itemStyle: props.itemStyle,\n    itemHeightEstimate: props.itemHeightEstimate,\n    itemKey: props.itemKey,\n    overscanBy: props.overscanBy,\n    height: props.height,\n    render: props.render,\n  })\n}\n\nexport interface MasonryScrollerProps<Item>\n  extends Omit<UseMasonryOptions<Item>, 'scrollTop' | 'isScrolling'> {\n  /**\n   * This determines how often (in frames per second) to update the scroll position of the\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\n   * heavy `render` components it may be prudent to reduce this number.\n   * @default 12\n   */\n  scrollFps?: number\n  /**\n   * The vertical space in pixels between the top of the grid container and the top\n   * of the browser `document.documentElement`.\n   * @default 0\n   */\n  offset?: number\n}\n\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n  MasonryScroller.displayName = 'MasonryScroller'\n}\n","import * as React from 'react'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\n\n/**\n * A hook for measuring the width of the grid container, as well as its distance\n * from the top of the document. These values are necessary to correctly calculate the number/width\n * of columns to render, as well as the number of rows to render.\n *\n * @param elementRef A `ref` object created by `React.useRef()`. That ref should be provided to the\n *   `containerRef` property in `useMasonry()`.\n * @param deps You can force this hook to recalculate the `offset` and `width` whenever this\n *   dependencies list changes. A common dependencies list might look like `[windowWidth, windowHeight]`,\n *   which would force the hook to recalculate any time the size of the browser `window` changed.\n */\nexport function useContainerPosition(\n  elementRef: React.MutableRefObject<HTMLElement | null>,\n  deps: React.DependencyList = emptyArr\n): ContainerPosition {\n  const [containerPosition, setContainerPosition] = React.useState<\n    ContainerPosition\n  >({offset: 0, width: 0})\n\n  useLayoutEffect(() => {\n    const {current} = elementRef\n    if (current !== null) {\n      let offset = 0\n      let el = current\n\n      do {\n        offset += el.offsetTop || 0\n        el = el.offsetParent as HTMLElement\n      } while (el)\n\n      if (\n        offset !== containerPosition.offset ||\n        current.offsetWidth !== containerPosition.width\n      ) {\n        setContainerPosition({\n          offset,\n          width: current.offsetWidth,\n        })\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n\n  return containerPosition\n}\n\nexport interface ContainerPosition {\n  /**\n   * The distance in pixels between the top of the element in `elementRef` and the top of\n   * the `document.documentElement`.\n   */\n  offset: number\n  /**\n   * The `offsetWidth` of the element in `elementRef`.\n   */\n  width: number\n}\n\nconst emptyArr: [] = []\n","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nexport default index;\n","import * as React from 'react'\nimport trieMemoize from 'trie-memoize'\nimport ResizeObserver from 'resize-observer-polyfill'\nimport rafSchd from 'raf-schd'\nimport {elementsCache} from './elements-cache'\nimport {useForceUpdate} from './use-force-update'\nimport type {Positioner} from './use-positioner'\n\n/**\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\n * made to cells affecting their height.\n *\n * @param positioner The masonry cell positioner created by the `usePositioner()` hook.\n */\nexport function useResizeObserver(positioner: Positioner) {\n  const forceUpdate = useForceUpdate()\n  const resizeObserver = createResizeObserver(positioner, forceUpdate)\n  // Cleans up the resize observers when they change or the\n  // component unmounts\n  React.useEffect(() => () => resizeObserver.disconnect(), [resizeObserver])\n  return resizeObserver\n}\n\n/**\n * Creates a resize observer that fires an `updater` callback whenever the height of\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\n *\n * @param positioner A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\n * @param updater A callback that fires whenever one or many cell heights change.\n */\nexport const createResizeObserver = trieMemoize(\n  [WeakMap],\n  // TODO: figure out a way to test this\n  /* istanbul ignore next */\n  (positioner: Positioner, updater: (updates: number[]) => void) => {\n    const handleEntries = rafSchd(((entries) => {\n      const updates: number[] = []\n      let i = 0\n\n      for (; i < entries.length; i++) {\n        const entry = entries[i]\n        const height = (entry.target as HTMLElement).offsetHeight\n\n        if (height > 0) {\n          const index = elementsCache.get(entry.target)\n\n          if (index !== void 0) {\n            const position = positioner.get(index)\n\n            if (position !== void 0 && height !== position.height)\n              updates.push(index, height)\n          }\n        }\n      }\n\n      if (updates.length > 0) {\n        // Updates the size/positions of the cell with the resize\n        // observer updates\n        positioner.update(updates)\n        updater(updates)\n      }\n    }) as ResizeObserverCallback)\n\n    const ro = new ResizeObserver(handleEntries)\n    // Overrides the original disconnect to include cancelling handling the entries.\n    // Ideally this would be its own method but that would result in a breaking\n    // change.\n    const disconnect = ro.disconnect.bind(ro)\n    ro.disconnect = () => {\n      disconnect()\n      handleEntries.cancel()\n    }\n\n    return ro\n  }\n)\n","type Color = 0 | 1 | 2\nconst RED = 0\nconst BLACK = 1\nconst NIL = 2\n\nconst DELETE = 0\nconst KEEP = 1\n\ntype ListNode = {\n  index: number\n  high: number\n  next: ListNode | null\n}\n\ninterface TreeNode {\n  max: number\n  low: number\n  high: number\n  // color\n  C: Color\n  // P\n  P: TreeNode\n  // right\n  R: TreeNode\n  // left\n  L: TreeNode\n  list: ListNode\n}\n\ninterface Tree {\n  root: TreeNode\n  size: number\n}\n\nfunction addInterval(treeNode: TreeNode, high: number, index: number): boolean {\n  let node: ListNode | null = treeNode.list\n  let prevNode: ListNode | undefined\n\n  while (node) {\n    if (node.index === index) return false\n    if (high > node.high) break\n    prevNode = node\n    node = node.next\n  }\n\n  if (!prevNode) treeNode.list = {index, high, next: node}\n  if (prevNode) prevNode.next = {index, high, next: prevNode.next}\n\n  return true\n}\n\nfunction removeInterval(treeNode: TreeNode, index: number) {\n  let node: ListNode | null = treeNode.list\n  if (node.index === index) {\n    if (node.next === null) return DELETE\n    treeNode.list = node.next\n    return KEEP\n  }\n\n  let prevNode: ListNode | undefined = node\n  node = node.next\n\n  while (node !== null) {\n    if (node.index === index) {\n      prevNode.next = node.next\n      return KEEP\n    }\n    prevNode = node\n    node = node.next\n  }\n}\n\nconst NULL_NODE: TreeNode = {\n  low: 0,\n  max: 0,\n  high: 0,\n  C: NIL,\n  // @ts-ignore\n  P: undefined,\n  // @ts-ignore\n  R: undefined,\n  // @ts-ignore\n  L: undefined,\n  // @ts-ignore\n  list: undefined,\n}\n\nNULL_NODE.P = NULL_NODE\nNULL_NODE.L = NULL_NODE\nNULL_NODE.R = NULL_NODE\n\nfunction updateMax(node: TreeNode) {\n  const max = node.high\n  if (node.L === NULL_NODE && node.R === NULL_NODE) node.max = max\n  else if (node.L === NULL_NODE) node.max = Math.max(node.R.max, max)\n  else if (node.R === NULL_NODE) node.max = Math.max(node.L.max, max)\n  else node.max = Math.max(Math.max(node.L.max, node.R.max), max)\n}\n\nfunction updateMaxUp(node: TreeNode) {\n  let x = node\n\n  while (x.P !== NULL_NODE) {\n    updateMax(x.P)\n    x = x.P\n  }\n}\n\nfunction rotateLeft(tree: Tree, x: TreeNode) {\n  if (x.R === NULL_NODE) return\n  const y = x.R\n  x.R = y.L\n  if (y.L !== NULL_NODE) y.L.P = x\n  y.P = x.P\n\n  if (x.P === NULL_NODE) tree.root = y\n  else {\n    if (x === x.P.L) x.P.L = y\n    else x.P.R = y\n  }\n\n  y.L = x\n  x.P = y\n\n  updateMax(x)\n  updateMax(y)\n}\n\nfunction rotateRight(tree: Tree, x: TreeNode) {\n  if (x.L === NULL_NODE) return\n  const y = x.L\n  x.L = y.R\n  if (y.R !== NULL_NODE) y.R.P = x\n  y.P = x.P\n\n  if (x.P === NULL_NODE) tree.root = y\n  else {\n    if (x === x.P.R) x.P.R = y\n    else x.P.L = y\n  }\n\n  y.R = x\n  x.P = y\n\n  updateMax(x)\n  updateMax(y)\n}\n\nfunction replaceNode(tree: Tree, x: TreeNode, y: TreeNode) {\n  if (x.P === NULL_NODE) tree.root = y\n  else if (x === x.P.L) x.P.L = y\n  else x.P.R = y\n  y.P = x.P\n}\n\nfunction fixRemove(tree: Tree, x: TreeNode) {\n  let w\n\n  while (x !== NULL_NODE && x.C === BLACK) {\n    if (x === x.P.L) {\n      w = x.P.R\n\n      if (w.C === RED) {\n        w.C = BLACK\n        x.P.C = RED\n        rotateLeft(tree, x.P)\n        w = x.P.R\n      }\n\n      if (w.L.C === BLACK && w.R.C === BLACK) {\n        w.C = RED\n        x = x.P\n      } else {\n        if (w.R.C === BLACK) {\n          w.L.C = BLACK\n          w.C = RED\n          rotateRight(tree, w)\n          w = x.P.R\n        }\n\n        w.C = x.P.C\n        x.P.C = BLACK\n        w.R.C = BLACK\n        rotateLeft(tree, x.P)\n        x = tree.root\n      }\n    } else {\n      w = x.P.L\n\n      if (w.C === RED) {\n        w.C = BLACK\n        x.P.C = RED\n        rotateRight(tree, x.P)\n        w = x.P.L\n      }\n\n      if (w.R.C === BLACK && w.L.C === BLACK) {\n        w.C = RED\n        x = x.P\n      } else {\n        if (w.L.C === BLACK) {\n          w.R.C = BLACK\n          w.C = RED\n          rotateLeft(tree, w)\n          w = x.P.L\n        }\n\n        w.C = x.P.C\n        x.P.C = BLACK\n        w.L.C = BLACK\n        rotateRight(tree, x.P)\n        x = tree.root\n      }\n    }\n  }\n\n  x.C = BLACK\n}\n\nfunction minimumTree(x: TreeNode) {\n  while (x.L !== NULL_NODE) x = x.L\n  return x\n}\n\nfunction fixInsert(tree: Tree, z: TreeNode) {\n  let y: TreeNode\n  while (z.P.C === RED) {\n    if (z.P === z.P.P.L) {\n      y = z.P.P.R\n\n      if (y.C === RED) {\n        z.P.C = BLACK\n        y.C = BLACK\n        z.P.P.C = RED\n        z = z.P.P\n      } else {\n        if (z === z.P.R) {\n          z = z.P\n          rotateLeft(tree, z)\n        }\n\n        z.P.C = BLACK\n        z.P.P.C = RED\n        rotateRight(tree, z.P.P)\n      }\n    } else {\n      y = z.P.P.L\n\n      if (y.C === RED) {\n        z.P.C = BLACK\n        y.C = BLACK\n        z.P.P.C = RED\n        z = z.P.P\n      } else {\n        if (z === z.P.L) {\n          z = z.P\n          rotateRight(tree, z)\n        }\n\n        z.P.C = BLACK\n        z.P.P.C = RED\n        rotateLeft(tree, z.P.P)\n      }\n    }\n  }\n  tree.root.C = BLACK\n}\n\nexport interface IIntervalTree {\n  insert(low: number, high: number, index: number): void\n  remove(index: number): void\n  search(\n    low: number,\n    high: number,\n    callback: (index: number, low: number) => any\n  ): void\n  size: number\n}\n\nexport function createIntervalTree(): IIntervalTree {\n  const tree = {\n    root: NULL_NODE,\n    size: 0,\n  }\n  // we know these indexes are a consistent, safe way to make look ups\n  // for our case so it's a solid O(1) alternative to\n  // the O(log n) searchNode() in typical interval trees\n  const indexMap: Record<number, TreeNode> = {}\n\n  return {\n    insert(low, high, index) {\n      let x: TreeNode = tree.root\n      let y: TreeNode = NULL_NODE\n\n      while (x !== NULL_NODE) {\n        y = x\n        if (low === y.low) break\n        if (low < x.low) x = x.L\n        else x = x.R\n      }\n\n      if (low === y.low && y !== NULL_NODE) {\n        if (!addInterval(y, high, index)) return\n        y.high = Math.max(y.high, high)\n        updateMax(y)\n        updateMaxUp(y)\n        indexMap[index] = y\n        tree.size++\n        return\n      }\n\n      const z: TreeNode = {\n        low,\n        high,\n        max: high,\n        C: RED,\n        P: y,\n        L: NULL_NODE,\n        R: NULL_NODE,\n        list: {index, high, next: null},\n      }\n\n      if (y === NULL_NODE) {\n        tree.root = z\n      } else {\n        if (z.low < y.low) y.L = z\n        else y.R = z\n        updateMaxUp(z)\n      }\n\n      fixInsert(tree, z)\n      indexMap[index] = z\n      tree.size++\n    },\n\n    remove(index) {\n      const z = indexMap[index]\n      if (z === void 0) return\n      delete indexMap[index]\n\n      const intervalResult = removeInterval(z, index)\n      if (intervalResult === void 0) return\n      if (intervalResult === KEEP) {\n        z.high = z.list.high\n        updateMax(z)\n        updateMaxUp(z)\n        tree.size--\n        return\n      }\n\n      let y = z\n      let originalYColor = y.C\n      let x: TreeNode\n\n      if (z.L === NULL_NODE) {\n        x = z.R\n        replaceNode(tree, z, z.R)\n      } else if (z.R === NULL_NODE) {\n        x = z.L\n        replaceNode(tree, z, z.L)\n      } else {\n        y = minimumTree(z.R)\n        originalYColor = y.C\n        x = y.R\n\n        if (y.P === z) {\n          x.P = y\n        } else {\n          replaceNode(tree, y, y.R)\n          y.R = z.R\n          y.R.P = y\n        }\n\n        replaceNode(tree, z, y)\n        y.L = z.L\n        y.L.P = y\n        y.C = z.C\n      }\n\n      updateMax(x)\n      updateMaxUp(x)\n\n      if (originalYColor === BLACK) fixRemove(tree, x)\n      tree.size--\n    },\n\n    search(low, high, callback) {\n      const stack = [tree.root]\n      while (stack.length !== 0) {\n        const node = stack.pop() as TreeNode\n        if (node === NULL_NODE || low > node.max) continue\n        if (node.L !== NULL_NODE) stack.push(node.L)\n        if (node.R !== NULL_NODE) stack.push(node.R)\n        if (node.low <= high && node.high >= low) {\n          let curr: ListNode | null = node.list\n          while (curr !== null) {\n            if (curr.high >= low) callback(curr.index, node.low)\n            curr = curr.next\n          }\n        }\n      }\n    },\n\n    get size() {\n      return tree.size\n    },\n  }\n}\n","import * as React from 'react'\nimport {createIntervalTree} from './interval-tree'\n\n/**\n * This hook creates the grid cell positioner and cache required by `useMasonry()`. This is\n * the meat of the grid's layout algorithm, determining which cells to render at a given scroll\n * position, as well as where to place new items in the grid.\n *\n * @param options Properties that determine the number of columns in the grid, as well\n *  as their widths.\n * @param deps This hook will create a new positioner, clearing all existing cached positions,\n *  whenever the dependencies in this list change.\n */\nexport function usePositioner(\n  {\n    width,\n    columnWidth = 200,\n    columnGutter = 0,\n    columnCount,\n  }: UsePositionerOptions,\n  deps: React.DependencyList = emptyArr\n): Positioner {\n  const initPositioner = (): Positioner => {\n    const [computedColumnWidth, computedColumnCount] = getColumns(\n      width,\n      columnWidth,\n      columnGutter,\n      columnCount\n    )\n    return createPositioner(\n      computedColumnCount,\n      computedColumnWidth,\n      columnGutter\n    )\n  }\n  const positionerRef = React.useRef<Positioner>()\n  if (positionerRef.current === undefined)\n    positionerRef.current = initPositioner()\n\n  const prevDeps = React.useRef(deps)\n  const opts = [width, columnWidth, columnGutter, columnCount]\n  const prevOpts = React.useRef(opts)\n  const optsChanged = !opts.every((item, i) => prevOpts.current[i] === item)\n\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n    if (deps.length !== prevDeps.current.length) {\n      throw new Error(\n        'usePositioner(): The length of your dependencies array changed.'\n      )\n    }\n  }\n\n  // Create a new positioner when the dependencies or sizes change\n  // Thanks to https://github.com/khmm12 for pointing this out\n  // https://github.com/jaredLunde/masonic/pull/41\n  if (optsChanged || !deps.every((item, i) => prevDeps.current[i] === item)) {\n    const prevPositioner = positionerRef.current\n    const positioner = initPositioner()\n    prevDeps.current = deps\n    prevOpts.current = opts\n\n    if (optsChanged) {\n      const cacheSize = prevPositioner.size()\n      for (let index = 0; index < cacheSize; index++) {\n        const pos = prevPositioner.get(index)\n        positioner.set(index, pos !== void 0 ? pos.height : 0)\n      }\n    }\n\n    positionerRef.current = positioner\n  }\n\n  return positionerRef.current\n}\n\nexport interface UsePositionerOptions {\n  /**\n   * The width of the container you're rendering the grid within, i.e. the container\n   * element's `element.offsetWidth`\n   */\n  width: number\n  /**\n   * The minimum column width. The `usePositioner()` hook will automatically size the\n   * columns to fill their container based upon the `columnWidth` and `columnGutter` values.\n   * It will never render anything smaller than this width unless its container itself is\n   * smaller than its value. This property is optional if you're using a static `columnCount`.\n   * @default 200\n   */\n  columnWidth?: number\n  /**\n   * This sets the vertical and horizontal space between grid cells in pixels.\n   */\n  columnGutter?: number\n  /**\n   * By default, `usePositioner()` derives the column count from the `columnWidth`, `columnGutter`,\n   * and `width` props. However, in some situations it is nice to be able to override that behavior\n   * (e.g. creating a `List` component).\n   */\n  columnCount?: number\n}\n\n/**\n * Creates a cell positioner for the `useMasonry()` hook. The `usePositioner()` hook uses\n * this utility under the hood.\n *\n * @param columnCount The number of columns in the grid\n * @param columnWidth The width of each column in the grid\n * @param columnGutter The amount of horizontal and vertical space in pixels to render\n *  between each grid item.\n */\nexport const createPositioner = (\n  columnCount: number,\n  columnWidth: number,\n  columnGutter = 0\n): Positioner => {\n  // O(log(n)) lookup of cells to render for a given viewport size\n  // Store tops and bottoms of each cell for fast intersection lookup.\n  const intervalTree = createIntervalTree()\n  // Track the height of each column.\n  // Layout algorithm below always inserts into the shortest column.\n  const columnHeights: number[] = new Array(columnCount)\n  // Used for O(1) item access\n  const items: PositionerItem[] = []\n  // Tracks the item indexes within an individual column\n  const columnItems: number[][] = new Array(columnCount)\n\n  for (let i = 0; i < columnCount; i++) {\n    columnHeights[i] = 0\n    columnItems[i] = []\n  }\n\n  return {\n    columnCount,\n    columnWidth,\n    set: (index, height = 0) => {\n      let column = 0\n\n      // finds the shortest column and uses it\n      for (let i = 1; i < columnHeights.length; i++) {\n        if (columnHeights[i] < columnHeights[column]) column = i\n      }\n\n      const top = columnHeights[column] || 0\n      columnHeights[column] = top + height + columnGutter\n      columnItems[column].push(index)\n      items[index] = {\n        left: column * (columnWidth + columnGutter),\n        top,\n        height,\n        column,\n      }\n      intervalTree.insert(top, top + height, index)\n    },\n    get: (index) => items[index],\n    // This only updates items in the specific columns that have changed, on and after the\n    // specific items that have changed\n    update: (updates) => {\n      const columns: number[] = new Array(columnCount)\n      let i = 0,\n        j = 0\n\n      // determines which columns have items that changed, as well as the minimum index\n      // changed in that column, as all items after that index will have their positions\n      // affected by the change\n      for (; i < updates.length - 1; i++) {\n        const index = updates[i]\n        const item = items[index]\n        item.height = updates[++i]\n        intervalTree.remove(index)\n        intervalTree.insert(item.top, item.top + item.height, index)\n        columns[item.column] =\n          columns[item.column] === void 0\n            ? index\n            : Math.min(index, columns[item.column])\n      }\n\n      for (i = 0; i < columns.length; i++) {\n        // bails out if the column didn't change\n        if (columns[i] === void 0) continue\n        const itemsInColumn = columnItems[i]\n        // the index order is sorted with certainty so binary search is a great solution\n        // here as opposed to Array.indexOf()\n        const startIndex = binarySearch(itemsInColumn, columns[i])\n        const index = columnItems[i][startIndex]\n        const startItem = items[index]\n        columnHeights[i] = startItem.top + startItem.height + columnGutter\n\n        for (j = startIndex + 1; j < itemsInColumn.length; j++) {\n          const index = itemsInColumn[j]\n          const item = items[index]\n          item.top = columnHeights[i]\n          columnHeights[i] = item.top + item.height + columnGutter\n          intervalTree.remove(index)\n          intervalTree.insert(item.top, item.top + item.height, index)\n        }\n      }\n    },\n    // Render all cells visible within the viewport range defined.\n    range: (lo, hi, renderCallback) =>\n      intervalTree.search(lo, hi, (index, top) =>\n        renderCallback(index, items[index].left, top)\n      ),\n    estimateHeight: (itemCount, defaultItemHeight): number => {\n      const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights))\n\n      return itemCount === intervalTree.size\n        ? tallestColumn\n        : tallestColumn +\n            Math.ceil((itemCount - intervalTree.size) / columnCount) *\n              defaultItemHeight\n    },\n    shortestColumn: () => {\n      if (columnHeights.length > 1) return Math.min.apply(null, columnHeights)\n      return columnHeights[0] || 0\n    },\n    size(): number {\n      return intervalTree.size\n    },\n  }\n}\n\nexport interface Positioner {\n  /**\n   * The number of columns in the grid\n   */\n  columnCount: number\n  /**\n   * The width of each column in the grid\n   */\n  columnWidth: number\n  /**\n   * Sets the position for the cell at `index` based upon the cell's height\n   */\n  set: (index: number, height: number) => void\n  /**\n   * Gets the `PositionerItem` for the cell at `index`\n   */\n  get: (index: number) => PositionerItem | undefined\n  /**\n   * Updates cells based on their indexes and heights\n   * positioner.update([index, height, index, height, index, height...])\n   */\n  update: (updates: number[]) => void\n  /**\n   * Searches the interval tree for grid cells with a `top` value in\n   * betwen `lo` and `hi` and invokes the callback for each item that\n   * is discovered\n   */\n  range: (\n    lo: number,\n    hi: number,\n    renderCallback: (index: number, left: number, top: number) => void\n  ) => void\n  /**\n   * Returns the number of grid cells in the cache\n   */\n\n  size: () => number\n  /**\n   * Estimates the total height of the grid\n   */\n\n  estimateHeight: (itemCount: number, defaultItemHeight: number) => number\n  /**\n   * Returns the height of the shortest column in the grid\n   */\n\n  shortestColumn: () => number\n}\n\nexport interface PositionerItem {\n  /**\n   * This is how far from the top edge of the grid container in pixels the\n   * item is placed\n   */\n  top: number\n  /**\n   * This is how far from the left edge of the grid container in pixels the\n   * item is placed\n   */\n  left: number\n  /**\n   * This is the height of the grid cell\n   */\n  height: number\n  /**\n   * This is the column number containing the grid cell\n   */\n  column: number\n}\n\n/* istanbul ignore next */\nconst binarySearch = (a: number[], y: number): number => {\n  let l = 0\n  let h = a.length - 1\n\n  while (l <= h) {\n    const m = (l + h) >>> 1\n    const x = a[m]\n    if (x === y) return m\n    else if (x <= y) l = m + 1\n    else h = m - 1\n  }\n\n  return -1\n}\n\nconst getColumns = (\n  width = 0,\n  minimumWidth = 0,\n  gutter = 8,\n  columnCount?: number\n): [number, number] => {\n  columnCount = columnCount || Math.floor(width / (minimumWidth + gutter)) || 1\n  const columnWidth = Math.floor(\n    (width - gutter * (columnCount - 1)) / columnCount\n  )\n  return [columnWidth, columnCount]\n}\n\nconst emptyArr: [] = []\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\nimport useEvent from '@react-hook/event'\nimport {useThrottleCallback} from '@react-hook/throttle'\nimport type {Positioner, PositionerItem} from './use-positioner'\n\n/**\n * A hook that creates a callback for scrolling to a specific index in\n * the \"items\" array.\n *\n * @param positioner A positioner created by the `usePositioner()` hook\n * @param options Configuration options\n */\nexport function useScrollToIndex(\n  positioner: Positioner,\n  options: UseScrollToIndexOptions\n) {\n  const {\n    align = 'top',\n    element = typeof window !== 'undefined' && window,\n    offset = 0,\n    height = typeof window !== 'undefined' ? window.innerHeight : 0,\n  } = options\n  const latestOptions = useLatest({\n    positioner,\n    element,\n    align,\n    offset,\n    height,\n  } as const)\n  const getTarget = React.useRef(() => {\n    const latestElement = latestOptions.current.element\n    return latestElement && 'current' in latestElement\n      ? latestElement.current\n      : latestElement\n  }).current\n  const [state, dispatch] = React.useReducer(\n    (\n      state: {\n        position: PositionerItem | undefined\n        index: number | undefined\n        prevTop: number | undefined\n      },\n      action:\n        | {type: 'scrollToIndex'; value: number | undefined}\n        | {type: 'setPosition'; value: PositionerItem | undefined}\n        | {type: 'setPrevTop'; value: number | undefined}\n        | {type: 'reset'}\n    ) => {\n      const nextState = {\n        position: state.position,\n        index: state.index,\n        prevTop: state.prevTop,\n      }\n\n      /* istanbul ignore next */\n      if (action.type === 'scrollToIndex') {\n        return {\n          position: latestOptions.current.positioner.get(action.value ?? -1),\n          index: action.value,\n          prevTop: void 0,\n        }\n      } else if (action.type === 'setPosition') {\n        nextState.position = action.value\n      } else if (action.type === 'setPrevTop') {\n        nextState.prevTop = action.value\n      } else if (action.type === 'reset') {\n        return defaultState\n      }\n\n      return nextState\n    },\n    defaultState\n  )\n  const throttledDispatch = useThrottleCallback(dispatch, 15)\n\n  // If we find the position along the way we can immediately take off\n  // to the correct spot.\n  useEvent(getTarget() as Window, 'scroll', () => {\n    if (!state.position && state.index) {\n      const position = latestOptions.current.positioner.get(state.index)\n\n      if (position) {\n        dispatch({type: 'setPosition', value: position})\n      }\n    }\n  })\n\n  // If the top changes out from under us in the case of dynamic cells, we\n  // want to keep following it.\n  const currentTop =\n    state.index !== void 0 &&\n    latestOptions.current.positioner.get(state.index)?.top\n\n  React.useEffect(() => {\n    const target = getTarget()\n    if (!target) return\n    const {height, align, offset, positioner} = latestOptions.current\n\n    if (state.position) {\n      let scrollTop = state.position.top\n\n      if (align === 'bottom') {\n        scrollTop = scrollTop - height + state.position.height\n      } else if (align === 'center') {\n        scrollTop -= (height - state.position.height) / 2\n      }\n\n      target.scrollTo(0, Math.max(0, (scrollTop += offset)))\n      // Resets state after 400ms, an arbitrary time I determined to be\n      // still visually pleasing if there is a slow network reply in dynamic\n      // cells\n      let didUnsubscribe = false\n      const timeout = setTimeout(\n        () => !didUnsubscribe && dispatch({type: 'reset'}),\n        400\n      )\n      return () => {\n        didUnsubscribe = true\n        clearTimeout(timeout)\n      }\n    } else if (state.index !== void 0) {\n      // Estimates the top based upon the average height of current cells\n      let estimatedTop =\n        (positioner.shortestColumn() / positioner.size()) * state.index\n      if (state.prevTop)\n        estimatedTop = Math.max(estimatedTop, state.prevTop + height)\n      target.scrollTo(0, estimatedTop)\n      throttledDispatch({type: 'setPrevTop', value: estimatedTop})\n    }\n  }, [currentTop, state, latestOptions, getTarget, throttledDispatch])\n\n  return React.useRef((index: number) => {\n    dispatch({type: 'scrollToIndex', value: index})\n  }).current\n}\n\nconst defaultState = {\n  index: void 0,\n  position: void 0,\n  prevTop: void 0,\n} as const\n\nexport type UseScrollToIndexOptions = {\n  /**\n   * The window element or a React ref for the window element. That is,\n   * this is the grid container.\n   * @default window\n   */\n  element?: Window | HTMLElement | React.RefObject<HTMLElement> | null\n  /**\n   * Sets the vertical alignment of the cell within the grid container.\n   * @default \"top\"\n   */\n  align?: 'center' | 'top' | 'bottom'\n  /**\n   * The height of the grid.\n   * @default window.innerHeight\n   */\n  height?: number\n  /**\n   * The vertical space in pixels between the top of the grid container and the top\n   * of the window.\n   * @default 0\n   */\n  offset?: number\n}\n","import * as React from 'react'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\nimport useLatest from '@react-hook/latest'\n\nfunction useEvent<\n  T extends Window = Window,\n  K extends keyof WindowEventMap = keyof WindowEventMap\n>(\n  target: Window | null,\n  type: K,\n  listener: WindowEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends Document = Document,\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n>(\n  target: Document | null,\n  type: K,\n  listener: DocumentEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends HTMLElement = HTMLElement,\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n>(\n  target: React.RefObject<T> | T | null,\n  type: K,\n  listener: ElementEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent(target: any, type: any, listener: any, cleanup: any): void {\n  const storedListener = useLatest(listener)\n  const storedCleanup = useLatest(cleanup)\n\n  useLayoutEffect(() => {\n    const targetEl = target && 'current' in target ? target.current : target\n    if (!targetEl) return\n\n    let didUnsubscribe = 0\n    function listener(this: any, ...args: any[]) {\n      if (didUnsubscribe) return\n      storedListener.current.apply(this, args)\n    }\n\n    targetEl.addEventListener(type, listener)\n    const cleanup = storedCleanup.current\n\n    return () => {\n      didUnsubscribe = 1\n      targetEl.removeEventListener(type, listener)\n      cleanup && cleanup()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, type])\n}\n\nexport type ElementEventListener<\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n> = (this: HTMLElement, ev: HTMLElementEventMap[K]) => any\n\nexport type DocumentEventListener<\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n> = (this: Document, ev: DocumentEventMap[K]) => any\n\nexport type WindowEventListener<\n  K extends keyof WindowEventMap = keyof WindowEventMap\n> = (this: Document, ev: WindowEventMap[K]) => any\n\nexport default useEvent\n","import * as React from 'react'\nimport {useWindowSize} from '@react-hook/window-size'\nimport {MasonryScroller} from './masonry-scroller'\nimport type {MasonryScrollerProps} from './masonry-scroller'\nimport {useContainerPosition} from './use-container-position'\nimport {useResizeObserver} from './use-resize-observer'\nimport {usePositioner} from './use-positioner'\nimport type {UsePositionerOptions} from './use-positioner'\nimport {useScrollToIndex} from './use-scroll-to-index'\nimport type {UseScrollToIndexOptions} from './use-scroll-to-index'\n\n/**\n * A \"batteries included\" masonry grid which includes all of the implementation details below. This component is the\n * easiest way to get off and running in your app, before switching to more advanced implementations, if necessary.\n * It will change its column count to fit its container's width and will decide how many rows to render based upon\n * the height of the browser `window`.\n */\nexport function Masonry<Item>(props: MasonryProps<Item>) {\n  const containerRef = React.useRef<null | HTMLElement>(null)\n  const windowSize = useWindowSize({\n    initialWidth: props.ssrWidth,\n    initialHeight: props.ssrHeight,\n  })\n  const containerPos = useContainerPosition(containerRef, windowSize)\n  const nextProps = Object.assign(\n    {\n      offset: containerPos.offset,\n      width: containerPos.width || windowSize[0],\n      height: windowSize[1],\n      containerRef,\n    },\n    props\n  ) as any\n  nextProps.positioner = usePositioner(nextProps)\n  nextProps.resizeObserver = useResizeObserver(nextProps.positioner)\n  const scrollToIndex = useScrollToIndex(nextProps.positioner, {\n    height: nextProps.height,\n    offset: containerPos.offset,\n    align:\n      typeof props.scrollToIndex === 'object'\n        ? props.scrollToIndex.align\n        : void 0,\n  })\n  const index =\n    props.scrollToIndex &&\n    (typeof props.scrollToIndex === 'number'\n      ? props.scrollToIndex\n      : props.scrollToIndex.index)\n\n  React.useEffect(() => {\n    if (index !== void 0) scrollToIndex(index)\n  }, [index, scrollToIndex])\n\n  return React.createElement(MasonryScroller, nextProps)\n}\n\nexport interface MasonryProps<Item>\n  extends Omit<\n      MasonryScrollerProps<Item>,\n      'offset' | 'width' | 'height' | 'containerRef' | 'positioner'\n    >,\n    Pick<UsePositionerOptions, 'columnWidth' | 'columnGutter' | 'columnCount'> {\n  /**\n   * Scrolls to a given index within the grid. The grid will re-scroll\n   * any time the index changes.\n   */\n  scrollToIndex?:\n    | number\n    | {\n        index: number\n        align: UseScrollToIndexOptions['align']\n      }\n  /**\n   * This is the width that will be used for the browser `window` when rendering this component in SSR.\n   * This prop isn't relevant for client-side only apps.\n   */\n  ssrWidth?: number\n  /**\n   * This is the height that will be used for the browser `window` when rendering this component in SSR.\n   * This prop isn't relevant for client-side only apps.\n   */\n  ssrHeight?: number\n  /**\n   * This determines how often (in frames per second) to update the scroll position of the\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\n   * heavy `render` components it may be prudent to reduce this number.\n   * @default 12\n   */\n  scrollFps?: number\n}\n\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n  Masonry.displayName = 'Masonry'\n}\n","import {useDebounce} from '@react-hook/debounce'\nimport useEvent from '@react-hook/event'\n\nconst emptyObj = {}\n\nexport interface DebouncedWindowSizeOptions {\n  initialWidth?: number\n  initialHeight?: number\n  wait?: number\n  leading?: boolean\n}\n\nconst win = typeof window === 'undefined' ? null : window\nconst getSize = () =>\n  [\n    document.documentElement.clientWidth,\n    document.documentElement.clientHeight,\n  ] as const\n\nexport const useWindowSize = (\n  options: DebouncedWindowSizeOptions = emptyObj\n): readonly [number, number] => {\n  const {wait, leading, initialWidth = 0, initialHeight = 0} = options\n  const [size, setDebouncedSize] = useDebounce<readonly [number, number]>(\n    /* istanbul ignore next */\n    typeof document === 'undefined' ? [initialWidth, initialHeight] : getSize,\n    wait,\n    leading\n  )\n  const setSize = (): void => setDebouncedSize(getSize)\n\n  useEvent(win, 'resize', setSize)\n  useEvent(win, 'orientationchange', setSize)\n\n  return size\n}\n\nexport const useWindowHeight = (\n  options?: Omit<DebouncedWindowSizeOptions, 'initialWidth'>\n): number => useWindowSize(options)[1]\n\nexport const useWindowWidth = (\n  options?: Omit<DebouncedWindowSizeOptions, 'initialHeight'>\n): number => useWindowSize(options)[0]\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\nexport const useDebounceCallback = <CallbackArgs extends any[]>(\n  callback: (...args: CallbackArgs) => void,\n  wait = 100,\n  leading = false\n): ((...args: CallbackArgs) => void) => {\n  const storedCallback = useLatest(callback)\n  const timeout = React.useRef<ReturnType<typeof setTimeout>>()\n  const deps = [wait, leading, storedCallback]\n  // Cleans up pending timeouts when the deps change\n  React.useEffect(\n    () => () => {\n      timeout.current && clearTimeout(timeout.current)\n      timeout.current = void 0\n    },\n    deps\n  )\n\n  return React.useCallback(function () {\n    // eslint-disable-next-line prefer-rest-params\n    const args = arguments\n    const {current} = timeout\n    // Calls on leading edge\n    if (current === void 0 && leading) {\n      timeout.current = setTimeout(() => {\n        timeout.current = void 0\n      }, wait)\n      // eslint-disable-next-line prefer-spread\n      return storedCallback.current.apply(null, args as any)\n    }\n    // Clear the timeout every call and start waiting again\n    current && clearTimeout(current)\n    // Waits for `wait` before invoking the callback\n    timeout.current = setTimeout(() => {\n      timeout.current = void 0\n      storedCallback.current.apply(null, args as any)\n    }, wait)\n  }, deps)\n}\n\nexport const useDebounce = <State extends any>(\n  initialState: State | (() => State),\n  wait?: number,\n  leading?: boolean\n): [State, React.Dispatch<React.SetStateAction<State>>] => {\n  const state = React.useState(initialState)\n  return [state[0], useDebounceCallback(state[1], wait, leading)]\n}\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  storedValue.current = current\n  return storedValue\n}\n\nexport default useLatest\n","import * as React from 'react'\n\nconst usePassiveLayoutEffect =\n  React[\n    typeof document !== 'undefined' && document.createElement !== void 0\n      ? 'useLayoutEffect'\n      : 'useEffect'\n  ]\n\nexport default usePassiveLayoutEffect\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  storedValue.current = current\n  return storedValue\n}\n\nexport default useLatest\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  storedValue.current = current\n  return storedValue\n}\n\nexport default useLatest\n","export type Raf = (callback: (timestamp: number) => void) => number\nexport type Caf = (handle: number) => void\n\nlet u = 'undefined',\n  win = typeof window !== u ? window : ({} as any),\n  p = typeof performance !== u ? performance : Date,\n  now = () => p.now(),\n  af = 'AnimationFrame' as const,\n  Caf = 'cancel' + af,\n  Raf = 'request' + af,\n  raf: Raf = win[Raf] && win[Raf].bind(win),\n  caf: Caf = win[Caf] && win[Caf].bind(win)\n\nif (!raf || !caf) {\n  let lastTime = 0\n  raf = (callback: FrameRequestCallback) => {\n    let curr = now(),\n      next = Math.max(lastTime + 1000 / 60, curr)\n    return setTimeout(() => {\n      callback((lastTime = next))\n    }, next - curr) as any\n  }\n  caf = (h) => clearTimeout(h)\n}\n\nexport {raf, caf, now}\n","export interface MapLike {\n  new (...args: any[]): any\n}\n\nexport type CacheConstructor =\n  | MapConstructor\n  | WeakMapConstructor\n  | MapLike\n  | Record<any, any>\n\ninterface Cache<K = any, V = any> {\n  set: (k: K, v: V) => V\n  get: (k: K) => V\n}\n\nconst createCache = (obj: CacheConstructor): Cache => {\n  try {\n    // @ts-ignore\n    return new obj()\n  } catch (e) {\n    const cache: Record<string, any> = {}\n\n    return {\n      set(k, v): void {\n        cache[k] = v\n      },\n      get(k): any {\n        return cache[k]\n      },\n    }\n  }\n}\n\nconst memo = (\n  constructors: CacheConstructor[]\n): {s: Cache['set']; g: Cache['get']} => {\n  const depth = constructors.length,\n    baseCache = createCache(constructors[0])\n  let base: any\n  let map: any\n  let i: number\n  let node: typeof baseCache\n  const one = depth === 1\n  // quicker access for one and two-argument functions\n  const g1 = (args: IArguments): any =>\n    (base = baseCache.get(args[0])) === void 0 || one ? base : base.get(args[1])\n  const s1 = (args: IArguments, value: any): any => {\n    if (one) baseCache.set(args[0], value)\n    else {\n      if ((base = baseCache.get(args[0])) === void 0) {\n        map = createCache(constructors[1])\n        map.set(args[1], value)\n        baseCache.set(args[0], map)\n      } else {\n        base.set(args[1], value)\n      }\n    }\n\n    return value\n  }\n\n  const g2 = (args: IArguments): any => {\n    node = baseCache\n\n    for (i = 0; i < depth; i++)\n      if ((node = node.get(args[i])) === void 0) return\n\n    return node\n  }\n\n  const s2 = (args: IArguments, value: any): any => {\n    node = baseCache\n\n    for (i = 0; i < depth - 1; i++) {\n      if ((map = node.get(args[i])) === void 0) {\n        map = createCache(constructors[i + 1])\n        node.set(args[i], map)\n        node = map\n      } else {\n        node = map\n      }\n    }\n\n    node.set(args[depth - 1], value)\n    return value\n  }\n\n  return depth < 3 ? {g: g1, s: s1} : {g: g2, s: s2}\n}\n\nconst memoize = <T extends any[], U extends any>(\n  mapConstructors: CacheConstructor[],\n  fn: (...args: T) => U\n): ((...args: T) => U) => {\n  let item: U\n  const {g, s} = memo(mapConstructors)\n  return function () {\n    return (item = g(arguments)) === void 0\n      ? s(arguments, fn.apply(null, arguments as any))\n      : item\n  }\n}\n\nexport default memoize\n","class OneKeyMap<K extends any = any, V extends any = any> {\n  set: (k: K, v: V) => void\n  get: (k: K) => V | undefined\n\n  constructor() {\n    let key: K | undefined, val: V | undefined\n    this.get = (k: K): V | undefined => (k === key ? val : void 0)\n    this.set = (k: K, v: V): void => {\n      key = k\n      val = v\n    }\n  }\n}\n\nexport default OneKeyMap\n","const memoOne = <Args extends any[], T extends any>(\n  fn: (...args: Args) => T,\n  areEqual?: AreEqual<Args>\n): OutputFunction<Args, T> => {\n  const equal = areEqual || defaultAreEqual\n  let args: Args, value: any\n\n  return function (): T {\n    return !!args && equal(arguments as any, args)\n      ? value\n      : (value = fn.apply(null, (args = arguments as any)))\n  } as OutputFunction<Args, T>\n}\n\nexport default memoOne\n\nconst defaultAreEqual = (\n  current: IArguments,\n  prev: IArguments | any[]\n): boolean =>\n  current[0] === prev[0] &&\n  current[1] === prev[1] &&\n  current[2] === prev[2] &&\n  current[3] === prev[3]\n\nexport type AreEqual<Args> = (currentArgs: Args, prevArgs: Args) => boolean\nexport type InputFunction = (...args: any[]) => any\nexport type OutputFunction<Args extends any[], T extends any> = (\n  ...args: Args\n) => T\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  React.useEffect(() => {\n    storedValue.current = current\n  })\n  return storedValue\n}\n\nexport default useLatest\n","export const elementsCache: WeakMap<Element, number> = new WeakMap()\n","var rafSchd = function rafSchd(fn) {\n  var lastArgs = [];\n  var frameId = null;\n\n  var wrapperFn = function wrapperFn() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n\n    if (frameId) {\n      return;\n    }\n\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      fn.apply(void 0, lastArgs);\n    });\n  };\n\n  wrapperFn.cancel = function () {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n  };\n\n  return wrapperFn;\n};\n\nexport default rafSchd;\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  storedValue.current = current\n  return storedValue\n}\n\nexport default useLatest\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\n/**\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\n * hook invokes a callback each time the last rendered index surpasses the total number of items\n * in your items array or the number defined in the `totalItems` option.\n *\n * @param loadMoreItems This callback is invoked when more rows must be loaded. It will be used to\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\n *  as well.\n * @param options\n */\nexport function useInfiniteLoader<Item, T extends LoadMoreItemsCallback<Item>>(\n  loadMoreItems: T,\n  options: UseInfiniteLoaderOptions<Item> = emptyObj\n): LoadMoreItemsCallback<Item> {\n  const {\n    isItemLoaded,\n    minimumBatchSize = 16,\n    threshold = 16,\n    totalItems = 9e9,\n  } = options\n  const storedLoadMoreItems = useLatest(loadMoreItems)\n  const storedIsItemLoaded = useLatest(isItemLoaded)\n\n  return React.useCallback(\n    (startIndex, stopIndex, items) => {\n      const unloadedRanges = scanForUnloadedRanges(\n        storedIsItemLoaded.current,\n        minimumBatchSize,\n        items,\n        totalItems,\n        Math.max(0, startIndex - threshold),\n        Math.min(totalItems - 1, (stopIndex || 0) + threshold)\n      )\n      // The user is responsible for memoizing their loadMoreItems() function\n      // because we don't want to make assumptions about how they want to deal\n      // with `items`\n      for (let i = 0; i < unloadedRanges.length - 1; ++i)\n        storedLoadMoreItems.current(\n          unloadedRanges[i],\n          unloadedRanges[++i],\n          items\n        )\n    },\n    [\n      totalItems,\n      minimumBatchSize,\n      threshold,\n      storedLoadMoreItems,\n      storedIsItemLoaded,\n    ]\n  )\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nfunction scanForUnloadedRanges<Item>(\n  isItemLoaded: UseInfiniteLoaderOptions<\n    Item\n  >['isItemLoaded'] = defaultIsItemLoaded,\n  minimumBatchSize: UseInfiniteLoaderOptions<Item>['minimumBatchSize'] = 16,\n  items: any[],\n  totalItems: UseInfiniteLoaderOptions<Item>['totalItems'] = 9e9,\n  startIndex: number,\n  stopIndex: number\n): number[] {\n  const unloadedRanges: number[] = []\n  let rangeStartIndex: number | undefined,\n    rangeStopIndex: number | undefined,\n    index = startIndex\n\n  /* istanbul ignore next */\n  for (; index <= stopIndex; index++) {\n    if (!isItemLoaded(index, items)) {\n      rangeStopIndex = index\n      if (rangeStartIndex === void 0) rangeStartIndex = index\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex)\n      rangeStartIndex = rangeStopIndex = void 0\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n    const potentialStopIndex = Math.min(\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\n      totalItems - 1\n    )\n\n    /* istanbul ignore next */\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isItemLoaded(index, items)) {\n        rangeStopIndex = index\n      } else {\n        break\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex)\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  /* istanbul ignore next */\n  if (unloadedRanges.length) {\n    let firstUnloadedStart = unloadedRanges[0]\n    const firstUnloadedStop = unloadedRanges[1]\n\n    while (\n      firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize &&\n      firstUnloadedStart > 0\n    ) {\n      const index = firstUnloadedStart - 1\n\n      if (!isItemLoaded(index, items)) {\n        unloadedRanges[0] = firstUnloadedStart = index\n      } else {\n        break\n      }\n    }\n  }\n\n  return unloadedRanges\n}\n\nconst defaultIsItemLoaded = <Item>(index: number, items: Item[]): boolean =>\n  items[index] !== void 0\n\nexport interface UseInfiniteLoaderOptions<Item> {\n  /**\n   *  A callback responsible for determining the loaded state of each item. Should return `true`\n   * if the item has already been loaded and `false` if not.\n   * @default (index: number, items: any[]) => boolean\n   */\n  isItemLoaded?: (index: number, items: Item[]) => boolean\n  /**\n   * The minimum number of new items to be loaded at a time.  This property can be used to\n   * batch requests and reduce HTTP requests.\n   * @default 16\n   */\n  minimumBatchSize?: number\n  /**\n   * The threshold at which to pre-fetch data. A threshold X means that new data should start\n   * loading when a user scrolls within X cells of the end of your `items` array.\n   * @default 16\n   */\n  threshold?: number\n  /**\n   * The total number of items you'll need to eventually load (if known). This can\n   * be arbitrarily high if not known.\n   * @default 9e9\n   */\n  totalItems?: number\n}\n\nexport type LoadMoreItemsCallback<Item> = (\n  startIndex: number,\n  stopIndex: number,\n  items: Item[]\n) => any\n\nconst emptyObj = {}\n","import * as React from 'react'\nimport {Masonry} from './masonry'\nimport type {MasonryProps} from './masonry'\n\n/**\n * This is just a single-column `<Masonry>` component with `rowGutter` prop instead of\n * a `columnGutter` prop.\n */\nexport function List<Item>(props: ListProps<Item>) {\n  return (\n    <Masonry<Item>\n      role='list'\n      columnGutter={props.rowGutter}\n      columnCount={1}\n      columnWidth={1}\n      {...props}\n    />\n  )\n}\n\nexport interface ListProps<Item>\n  extends Omit<\n    MasonryProps<Item>,\n    'columGutter' | 'columnCount' | 'columnWidth'\n  > {\n  /**\n   * The amount of vertical space in pixels to add between the list cells.\n   * @default 0\n   */\n  rowGutter?: number\n}\n\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n  List.displayName = 'List'\n}\n"],"names":["useEvent","target","type","listener","cleanup","args","storedListener","current","apply","this","noop","useLatest","storedCleanup","useLayoutEffect","targetEl","addEventListener","removeEventListener","useThrottleCallback","callback","fps","leading","prev","clearTrailing","storedValue","storedCallback","React","ms","trailingTimeout","clearTimeout","deps","arguments","rightNow","now","call","setTimeout","useScroller","offset","setIsScrolling","scrollTop","state","initialState","useThrottle","window","getScrollY","win","useScrollPosition","isScrolling","didMount","fn","start","handle","to","v","raf","loop","caf","clearRequestTimeout","Math","max","useForceUpdate","setState","emptyObj","useMasonry","stopIndex","positioner","resizeObserver","items","as","ContainerComponent","id","key","className","style","role","tabIndex","containerRef","itemAs","ItemComponent","itemStyle","itemHeightEstimate","itemKey","defaultGetItemKey","overscanBy","height","RenderComponent","render","onRender","startIndex","forceUpdate","setItemRef","getRefSetter","itemCount","length","columnWidth","columnCount","range","estimateHeight","size","shortestColumn","measuredCount","shortestColumnSize","children","itemRole","undefined","storedOnRender","rangeEnd","needsFreshBatch","index","left","top","data","phaseTwoStyle","width","writingMode","position","push","__reactCreateElement__","ref","_extends","createRenderElement","min","batchSize","ceil","phaseOneStyle","getCachedSize","didEverMount","containerStyle","getContainerStyle","assignUserStyle","_","i","MasonryScroller","props","scrollFps","useContainerPosition","elementRef","emptyArr","containerPosition","setContainerPosition","el","offsetTop","offsetParent","offsetWidth","getIndex","arr","result","some","entry","class_1","__entries__","value","entries","splice","ctx","_i","_a","Date","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","bind","refresh","resolvePending","leadingCall","trailingCall","proxy","timeoutCallback","requestAnimationFrame$1","timeStamp","lastCallTime","throttle","observer","indexOf","connect_","observers","disconnect_","updateObservers_","gatherActive","hasActive","broadcastActive","activeObservers","filter","forEach","isBrowser","document","mutationObserverSupported","MutationObserver","observe","attributes","childList","characterData","subtree","disconnect","_b","propertyName","transitionKeys","instance_","toFloat","parseFloat","getBordersSize","styles","positions","reduce","getWindowOf","SVGGraphicsElement","SVGElement","getBBox","getContentRect","isSVGGraphicsElement","bbox","createRectInit","getSVGContentRect","clientWidth","clientHeight","emptyRect","getComputedStyle","paddings","positions_1","getPaddings","horizPad","right","vertPad","bottom","boxSizing","round","documentElement","isDocumentElement","vertScrollbar","horizScrollbar","abs","getHTMLElementContentRect","x","y","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","rect","ResizeObserverEntry","rectInit","Constr","contentRect","DOMRectReadOnly","Object","create","prototype","defineConfigurable","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","MapShim","TypeError","callback_","controller_","callbackCtx_","Element","observations","has","set","addObserver","delete","removeObserver","clearActive","clear","_this","observation","isActive","broadcastRect","map","useResizeObserver","createResizeObserver","updateMax","node","high","L","NULL_NODE","R","updateMaxUp","P","rotateLeft","tree","root","rotateRight","replaceNode","createIntervalTree","indexMap","insert","low","treeNode","prevNode","list","next","addInterval","z","C","fixInsert","remove","intervalResult","removeInterval","originalYColor","minimumTree","w","fixRemove","search","stack","pop","curr","usePositioner","columnGutter","initPositioner","getColumns","computedColumnWidth","computedColumnCount","createPositioner","positionerRef","prevDeps","opts","prevOpts","optsChanged","every","item","prevPositioner","cacheSize","pos","get","useScrollToIndex","options","align","element","innerHeight","latestOptions","getTarget","latestElement","action","nextState","prevTop","defaultState","dispatch","throttledDispatch","didUnsubscribe","currentTop","_latestOptions$curren","scrollTo","timeout","estimatedTop","Masonry","windowSize","wait","initialWidth","initialHeight","useDebounceCallback","useDebounce","getSize","setDebouncedSize","setSize","useWindowSize","ssrWidth","ssrHeight","containerPos","nextProps","scrollToIndex","usePassiveLayoutEffect","createElement","perf","performance","scrollY","pageYOffset","u","p","af","Caf","Raf","lastTime","h","createCache","obj","e","cache","k","memoize","mapConstructors","constructors","base","depth","baseCache","one","g","s","OneKeyMap","val","memoOne","areEqual","equal","defaultAreEqual","elementsCache","WeakMap","trieMemoize","memoizeOne","maxWidth","maxHeight","willChange","pointerEvents","cmp2","pargs","userStyle","zIndex","visibility","offsetHeight","Map","defineProperty","enumerable","configurable","global$1","global","self","Function","requestAnimationFrame","getInstance","keys","writable","ownerDocument","defaultView","unobserve","ResizeObserver","method","updater","handleEntries","frameId","lastArgs","wrapperFn","_len","Array","_key","cancel","cancelAnimationFrame","rafSchd","updates","update","ro","intervalTree","columnHeights","columnItems","column","columns","j","itemsInColumn","binarySearch","startItem","lo","hi","renderCallback","defaultItemHeight","tallestColumn","a","l","m","minimumWidth","gutter","floor","defaultIsItemLoaded","rowGutter","loadMoreItems","isItemLoaded","minimumBatchSize","threshold","totalItems","storedLoadMoreItems","storedIsItemLoaded","unloadedRanges","rangeStartIndex","rangeStopIndex","potentialStopIndex","firstUnloadedStart","firstUnloadedStop","scanForUnloadedRanges"],"mappings":"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"}