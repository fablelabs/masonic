{"version":3,"file":"index.mjs","sources":["../../src/use-scroller.ts","../../src/use-force-update.ts","../../src/use-masonry.tsx","../../src/masonry-scroller.tsx","../../src/use-container-position.ts","../../src/use-resize-observer.ts","../../src/interval-tree.ts","../../src/use-positioner.ts","../../src/use-scroll-to-index.ts","../../src/masonry.tsx","../../src/list.tsx","../../src/use-infinite-loader.ts","../../src/elements-cache.ts"],"sourcesContent":["import * as React from 'react'\nimport useScrollPosition from '@react-hook/window-scroll'\nimport {requestTimeout, clearRequestTimeout} from '@essentials/request-timeout'\n\n/**\n * A hook for tracking whether the `window` is currently being scrolled and it's scroll position on\n * the y-axis. These values are used for determining which grid cells to render and when\n * to add styles to the masonry container that maximize scroll performance.\n *\n * @param offset The vertical space in pixels between the top of the grid container and the top\n *  of the browser `document.documentElement`.\n * @param fps This determines how often (in frames per second) to update the scroll position of the\n *  browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n *  The default value of `12` has been very reasonable in my own testing, but if you have particularly\n *  heavy `render` components it may be prudent to reduce this number.\n */\nexport function useScroller(\n  offset = 0,\n  fps = 12\n): {scrollTop: number; isScrolling: boolean} {\n  const scrollTop = useScrollPosition(fps)\n  const [isScrolling, setIsScrolling] = React.useState(false)\n  const didMount = React.useRef(0)\n\n  React.useEffect(() => {\n    if (didMount.current === 1) setIsScrolling(true)\n    const to = requestTimeout(() => {\n      // This is here to prevent premature bail outs while maintaining high resolution\n      // unsets. Without it there will always bee a lot of unnecessary DOM writes to style.\n      setIsScrolling(false)\n    }, 40 + 1000 / fps)\n    didMount.current = 1\n    return () => clearRequestTimeout(to)\n  }, [fps, scrollTop])\n\n  return {scrollTop: Math.max(0, scrollTop - offset), isScrolling}\n}\n","import * as React from 'react'\n\nexport function useForceUpdate() {\n  const setState = React.useState(emptyObj)[1]\n  return React.useRef(() => setState({})).current\n}\n\nconst emptyObj = {}\n","import * as React from 'react'\nimport trieMemoize from 'trie-memoize'\nimport OneKeyMap from '@essentials/one-key-map'\nimport memoizeOne from '@essentials/memoize-one'\nimport useLatest from '@react-hook/latest'\nimport {elementsCache} from './elements-cache'\nimport {useForceUpdate} from './use-force-update'\nimport {Positioner} from './use-positioner'\n\n/**\n * This hook handles the render phases of the masonry layout and returns the grid as a React element.\n *\n * @param options Options for configuring the masonry layout renderer. See `UseMasonryOptions`.\n */\nexport function useMasonry<Item> ({\n  // Measurement and layout\n  positioner,\n  resizeObserver,\n  // Grid items\n  items,\n  // Container props\n  as: ContainerComponent = 'div',\n  id,\n  key,\n  className,\n  style,\n  role = 'grid',\n  tabIndex = 0,\n  containerRef,\n  // Item props\n  itemAs: ItemComponent = 'div',\n  itemStyle,\n  itemHeightEstimate = 300,\n  itemKey = defaultGetItemKey,\n  // Rendering props\n  overscanBy = 2,\n  scrollTop,\n  isScrolling,\n  height,\n  render: RenderComponent,\n  onRender\n}: UseMasonryOptions<Item>) {\n  let startIndex = 0\n  let stopIndex: number | undefined\n  const forceUpdate = useForceUpdate()\n  const setItemRef = getRefSetter(positioner, resizeObserver)\n  const itemCount = items.length\n  const {\n    columnWidth,\n    columnCount,\n    range,\n    estimateHeight,\n    size,\n    shortestColumn\n  } = positioner\n  const measuredCount = size()\n  const shortestColumnSize = shortestColumn()\n  const children: React.ReactElement[] = []\n  const itemRole =\n    role === 'list' ? 'listitem' : role === 'grid' ? 'gridcell' : undefined\n  const storedOnRender = useLatest(onRender)\n\n  overscanBy = height * overscanBy\n  const rangeEnd = scrollTop + overscanBy\n  const needsFreshBatch =\n    shortestColumnSize < rangeEnd && measuredCount < itemCount\n\n  range(\n    // We overscan in both directions because users scroll both ways,\n    // though one must admit scrolling down is more common and thus\n    // we only overscan by half the downward overscan amount\n    Math.max(0, scrollTop - overscanBy / 2),\n    rangeEnd,\n    (index, left, top) => {\n      const data = items[index]\n      const key = itemKey(data, index)\n      const phaseTwoStyle: React.CSSProperties = {\n        top,\n        left,\n        width: columnWidth,\n        writingMode: 'horizontal-tb',\n        position: 'absolute'\n      }\n\n      /* istanbul ignore next */\n      if (\n        typeof process !== 'undefined' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        throwWithoutData(data, index)\n      }\n\n      children.push(\n        <ItemComponent\n          key={key}\n          ref={setItemRef(index)}\n          role={itemRole}\n          style={\n            typeof itemStyle === 'object' && itemStyle !== null\n              ? Object.assign({}, phaseTwoStyle, itemStyle)\n              : phaseTwoStyle\n          }\n        >\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\n        </ItemComponent>\n      )\n\n      if (stopIndex === void 0) {\n        startIndex = index\n        stopIndex = index\n      } else {\n        startIndex = Math.min(startIndex, index)\n        stopIndex = Math.max(stopIndex, index)\n      }\n    }\n  )\n\n  if (needsFreshBatch) {\n    const batchSize = Math.min(\n      itemCount - measuredCount,\n      Math.ceil(\n        ((scrollTop + overscanBy - shortestColumnSize) / itemHeightEstimate) *\n          columnCount\n      )\n    )\n\n    let index = measuredCount\n    const phaseOneStyle = getCachedSize(columnWidth)\n\n    for (; index < measuredCount + batchSize; index++) {\n      const data = items[index]\n      const key = itemKey(data, index)\n\n      /* istanbul ignore next */\n      if (\n        typeof process !== 'undefined' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        throwWithoutData(data, index)\n      }\n\n      children.push(\n        <ItemComponent\n          key={key}\n          ref={setItemRef(index)}\n          role={itemRole}\n          style={\n            typeof itemStyle === 'object'\n              ? Object.assign({}, phaseOneStyle, itemStyle)\n              : phaseOneStyle\n          }\n        >\n          {createRenderElement(RenderComponent, index, data, columnWidth)}\n        </ItemComponent>\n      )\n    }\n  }\n\n  // Calls the onRender callback if the rendered indices changed\n  React.useEffect(() => {\n    if (typeof storedOnRender.current === 'function' && stopIndex !== void 0)\n      storedOnRender.current(startIndex, stopIndex, items)\n\n    didEverMount = '1'\n  }, [startIndex, stopIndex, items, storedOnRender])\n  // If we needed a fresh batch we should reload our components with the measured\n  // sizes\n  React.useEffect(() => {\n    if (needsFreshBatch) forceUpdate()\n    // eslint-disable-next-line\n  }, [needsFreshBatch])\n\n  // gets the container style object based upon the estimated height and whether or not\n  // the page is being scrolled\n  const containerStyle = getContainerStyle(\n    isScrolling,\n    estimateHeight(itemCount, itemHeightEstimate)\n  )\n\n  return (\n    <ContainerComponent\n      ref={containerRef}\n      key={`${key || ''}-${didEverMount}`}\n      id={id}\n      role={role}\n      className={className}\n      tabIndex={tabIndex}\n      style={\n        typeof style === 'object'\n          ? assignUserStyle(containerStyle, style)\n          : containerStyle\n      }\n      children={children}\n    />\n  )\n}\n\n/* istanbul ignore next */\nfunction throwWithoutData (data: any, index: number) {\n  if (!data) {\n    throw new Error(\n      `No data was found at index: ${index}\\n\\n` +\n        `This usually happens when you've mutated or changed the \"items\" array in a ` +\n        `way that makes it shorter than the previous \"items\" array. Masonic knows nothing ` +\n        `about your underlying data and when it caches cell positions, it assumes you aren't ` +\n        `mutating the underlying \"items\".\\n\\n` +\n        `See https://codesandbox.io/s/masonic-w-react-router-example-2b5f9?file=/src/index.js for ` +\n        `an example that gets around this limitations. For advanced implementations, see ` +\n        `https://codesandbox.io/s/masonic-w-react-router-and-advanced-config-example-8em42?file=/src/index.js\\n\\n` +\n        `If this was the result of your removing an item from your \"items\", see this issue: ` +\n        `https://github.com/jaredLunde/masonic/issues/12`\n    )\n  }\n}\n\n// This is for triggering a remount after SSR has loaded in the client w/ hydrate()\nlet didEverMount = '0'\n\nexport interface UseMasonryOptions<Item> {\n  /**\n   * An array containing the data used by the grid items.\n   */\n  items: Item[]\n  /**\n   * A grid cell positioner and cache created by the `usePositioner()` hook or\n   * the `createPositioner` utility.\n   */\n  positioner: Positioner\n  /**\n   * A resize observer that tracks mutations to the grid cells and forces the\n   * Masonry grid to recalculate its layout if any cells affect column heights\n   * change. Check out the `useResizeObserver()` hook.\n   */\n  resizeObserver?: {\n    observe: ResizeObserver['observe']\n    disconnect: ResizeObserver['observe']\n    unobserve: ResizeObserver['unobserve']\n  }\n  /**\n   * This is the type of element the grid container will be rendered as.\n   * @default \"div\"`\n   */\n  as?: keyof JSX.IntrinsicElements | React.ComponentType<any>\n  /**\n   * Optionally gives the grid container an `id` prop.\n   */\n  id?: string\n  /**\n   * Prefix to key used for forcing re-renders\n   */\n  key?: string\n  /**\n   * Optionally gives the grid container a `className` prop.\n   */\n  className?: string\n  /**\n   * Adds extra `style` attributes to the container in addition to those\n   * created by the `useMasonry()` hook.\n   */\n  style?: React.CSSProperties\n  /**\n   * Optionally swap out the accessibility `role` prop of the container and its items.\n   * @default \"grid\"\n   */\n  role?: 'grid' | 'list'\n  /**\n   * Change the `tabIndex` of the grid container.\n   * @default 0\n   */\n  tabIndex?: number\n  /**\n   * Forwards a React ref to the grid container.\n   */\n  containerRef?:\n    | ((element: HTMLElement) => void)\n    | React.MutableRefObject<HTMLElement | null>\n  /**\n   * This is the type of element the grid items will be rendered as.\n   * @default \"div\"\n   */\n  itemAs?: keyof JSX.IntrinsicElements | React.ComponentType<any>\n  /**\n   * Adds extra `style` attributes to the grid items in addition to those\n   * created by the `useMasonry()` hook.\n   */\n  itemStyle?: React.CSSProperties\n  /**\n   * This value is used for estimating the initial height of the masonry grid. It is important for\n   * the UX of the scrolling behavior and in determining how many `items` to render in a batch, so it's\n   * wise to set this value with some level accuracy, though it doesn't need to be perfect.\n   * @default 300\n   */\n  itemHeightEstimate?: number\n  /**\n   * The value returned here must be unique to the item. By default, the key is the item's index. This is ok\n   * if your collection of items is never modified. Setting this property ensures that the component in `render`\n   * is reused each time the masonry grid is reflowed. A common pattern would be to return the item's database\n   * ID here if there is one, e.g. `data => data.id`\n   * @default (data, index) => index`\n   */\n  itemKey?: (data: Item, index: number) => string | number\n  /**\n   * This number is used for determining the number of grid cells outside of the visible window to render.\n   * The default value is `2` which means \"render 2 windows worth (2 * `height`) of content before and after\n   * the items in the visible window\". A value of `3` would be 3 windows worth of grid cells, so it's a\n   * linear relationship.\n   *\n   * Overscanning is important for preventing tearing when scrolling through items in the grid, but setting\n   * too high of a vaimport { useForceUpdate } from './use-force-update';\nlue may create too much work for React to handle, so it's best that you tune this\n   * value accordingly.\n   * @default 2\n   */\n  overscanBy?: number\n\n  /**\n   * This is the height of the window. If you're rendering the grid relative to the browser `window`,\n   * the current `document.documentElement.clientHeight` is the value you'll want to set here. If you're\n   * rendering the grid inside of another HTML element, you'll want to provide the current `element.offsetHeight`\n   * here.\n   */\n  height: number\n  /**\n   * The current scroll progress in pixel of the window the grid is rendered in. If you're rendering\n   * the grid relative to the browser `window`, you'll want the most current `window.scrollY` here.\n   * If you're rendering the grid inside of another HTML element, you'll want the current `element.scrollTop`\n   * value here. The `useScroller()` hook and `<MasonryScroller>` components will help you if you're\n   * rendering the grid relative to the browser `window`.\n   */\n  scrollTop: number\n  /**\n   * This property is used for determining whether or not the grid container should add styles that\n   * dramatically increase scroll performance. That is, turning off `pointer-events` and adding a\n   * `will-change: contents;` value to the style string. You can forgo using this prop, but I would\n   * not recommend that. The `useScroller()` hook and `<MasonryScroller>` components will help you if\n   * you're rendering the grid relative to the browser `window`.\n   * @default false\n   */\n  isScrolling?: boolean\n  /**\n   * This component is rendered for each item of your `items` prop array. It should accept three props:\n   * `index`, `width`, and `data`. See RenderComponentProps.\n   */\n  render: React.ComponentType<RenderComponentProps<Item>>\n  /**\n   * This callback is invoked any time the items currently being rendered by the grid change.\n   */\n  onRender?: (startIndex: number, stopIndex: number, items: Item[]) => void\n}\n\nexport interface RenderComponentProps<Item> {\n  /**\n   * The index of the cell in the `items` prop array.\n   */\n  index: number\n  /**\n   * The rendered width of the cell's column.\n   */\n  width: number\n  /**\n   * The data at `items[index]` of your `items` prop array.\n   */\n  data: Item\n}\n\n//\n// Render-phase utilities\n\n// ~5.5x faster than createElement without the memo\nconst createRenderElement = trieMemoize(\n  [OneKeyMap, {}, WeakMap, OneKeyMap],\n  (RenderComponent, index, data, columnWidth) => (\n    <RenderComponent index={index} data={data} width={columnWidth} />\n  )\n)\n\nconst getContainerStyle = memoizeOne(\n  (isScrolling: boolean | undefined, estimateHeight: number) => ({\n    position: 'relative',\n    width: '100%',\n    maxWidth: '100%',\n    height: Math.ceil(estimateHeight),\n    maxHeight: Math.ceil(estimateHeight),\n    willChange: isScrolling ? 'contents' : void 0,\n    pointerEvents: isScrolling ? 'none' : void 0\n  })\n)\n\nconst cmp2 = (args: IArguments, pargs: IArguments | any[]): boolean =>\n  args[0] === pargs[0] && args[1] === pargs[1]\n\nconst assignUserStyle = memoizeOne(\n  (containerStyle, userStyle) => Object.assign({}, containerStyle, userStyle),\n  // @ts-ignore\n  cmp2\n)\n\nfunction defaultGetItemKey<Item> (_: Item, i: number) {\n  return i\n}\n\n// the below memoizations for for ensuring shallow equal is reliable for pure\n// component children\nconst getCachedSize = memoizeOne(\n  (width: number): React.CSSProperties => ({\n    width,\n    zIndex: -1000,\n    visibility: 'hidden',\n    position: 'absolute',\n    writingMode: 'horizontal-tb'\n  }),\n  (args, pargs) => args[0] === pargs[0]\n)\n\nconst getRefSetter = memoizeOne(\n  (\n    positioner: Positioner,\n    resizeObserver?: UseMasonryOptions<any>['resizeObserver']\n  ) => (index: number) => (el: HTMLElement | null): void => {\n    if (el === null) return\n    if (resizeObserver) {\n      resizeObserver.observe(el)\n      elementsCache.set(el, index)\n    }\n    if (positioner.get(index) === void 0) positioner.set(index, el.offsetHeight)\n  },\n  // @ts-ignore\n  cmp2\n)\n","import {useScroller} from './use-scroller'\nimport {useMasonry} from './use-masonry'\nimport type {UseMasonryOptions} from './use-masonry'\n/**\n * A heavily-optimized component that updates `useMasonry()` when the scroll position of the browser `window`\n * changes. This bare-metal component is used by `<Masonry>` under the hood.\n */\nexport function MasonryScroller<Item>(props: MasonryScrollerProps<Item>) {\n  // We put this in its own layer because it's the thing that will trigger the most updates\n  // and we don't want to slower ourselves by cycling through all the functions, objects, and effects\n  // of other hooks\n  const {scrollTop, isScrolling} = useScroller(props.offset, props.scrollFps)\n  // This is an update-heavy phase and while we could just Object.assign here,\n  // it is way faster to inline and there's a relatively low hit to he bundle\n  // size.\n  return useMasonry<Item>({\n    scrollTop,\n    isScrolling,\n    positioner: props.positioner,\n    resizeObserver: props.resizeObserver,\n    items: props.items,\n    onRender: props.onRender,\n    as: props.as,\n    id: props.id,\n    className: props.className,\n    style: props.style,\n    role: props.role,\n    tabIndex: props.tabIndex,\n    containerRef: props.containerRef,\n    itemAs: props.itemAs,\n    itemStyle: props.itemStyle,\n    itemHeightEstimate: props.itemHeightEstimate,\n    itemKey: props.itemKey,\n    overscanBy: props.overscanBy,\n    height: props.height,\n    render: props.render,\n  })\n}\n\nexport interface MasonryScrollerProps<Item>\n  extends Omit<UseMasonryOptions<Item>, 'scrollTop' | 'isScrolling'> {\n  /**\n   * This determines how often (in frames per second) to update the scroll position of the\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\n   * heavy `render` components it may be prudent to reduce this number.\n   * @default 12\n   */\n  scrollFps?: number\n  /**\n   * The vertical space in pixels between the top of the grid container and the top\n   * of the browser `document.documentElement`.\n   * @default 0\n   */\n  offset?: number\n}\n\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n  MasonryScroller.displayName = 'MasonryScroller'\n}\n","import * as React from 'react'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\n\n/**\n * A hook for measuring the width of the grid container, as well as its distance\n * from the top of the document. These values are necessary to correctly calculate the number/width\n * of columns to render, as well as the number of rows to render.\n *\n * @param elementRef A `ref` object created by `React.useRef()`. That ref should be provided to the\n *   `containerRef` property in `useMasonry()`.\n * @param deps You can force this hook to recalculate the `offset` and `width` whenever this\n *   dependencies list changes. A common dependencies list might look like `[windowWidth, windowHeight]`,\n *   which would force the hook to recalculate any time the size of the browser `window` changed.\n */\nexport function useContainerPosition(\n  elementRef: React.MutableRefObject<HTMLElement | null>,\n  deps: React.DependencyList = emptyArr\n): ContainerPosition {\n  const [containerPosition, setContainerPosition] = React.useState<\n    ContainerPosition\n  >({offset: 0, width: 0})\n\n  useLayoutEffect(() => {\n    const {current} = elementRef\n    if (current !== null) {\n      let offset = 0\n      let el = current\n\n      do {\n        offset += el.offsetTop || 0\n        el = el.offsetParent as HTMLElement\n      } while (el)\n\n      if (\n        offset !== containerPosition.offset ||\n        current.offsetWidth !== containerPosition.width\n      ) {\n        setContainerPosition({\n          offset,\n          width: current.offsetWidth,\n        })\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n\n  return containerPosition\n}\n\nexport interface ContainerPosition {\n  /**\n   * The distance in pixels between the top of the element in `elementRef` and the top of\n   * the `document.documentElement`.\n   */\n  offset: number\n  /**\n   * The `offsetWidth` of the element in `elementRef`.\n   */\n  width: number\n}\n\nconst emptyArr: [] = []\n","import * as React from 'react'\nimport trieMemoize from 'trie-memoize'\nimport ResizeObserver from 'resize-observer-polyfill'\nimport rafSchd from 'raf-schd'\nimport {elementsCache} from './elements-cache'\nimport {useForceUpdate} from './use-force-update'\nimport type {Positioner} from './use-positioner'\n\n/**\n * Creates a resize observer that forces updates to the grid cell positions when mutations are\n * made to cells affecting their height.\n *\n * @param positioner The masonry cell positioner created by the `usePositioner()` hook.\n */\nexport function useResizeObserver(positioner: Positioner) {\n  const forceUpdate = useForceUpdate()\n  const resizeObserver = createResizeObserver(positioner, forceUpdate)\n  // Cleans up the resize observers when they change or the\n  // component unmounts\n  React.useEffect(() => () => resizeObserver.disconnect(), [resizeObserver])\n  return resizeObserver\n}\n\n/**\n * Creates a resize observer that fires an `updater` callback whenever the height of\n * one or many cells change. The `useResizeObserver()` hook is using this under the hood.\n *\n * @param positioner A cell positioner created by the `usePositioner()` hook or the `createPositioner()` utility\n * @param updater A callback that fires whenever one or many cell heights change.\n */\nexport const createResizeObserver = trieMemoize(\n  [WeakMap],\n  // TODO: figure out a way to test this\n  /* istanbul ignore next */\n  (positioner: Positioner, updater: (updates: number[]) => void) => {\n    const handleEntries = rafSchd(((entries) => {\n      const updates: number[] = []\n      let i = 0\n\n      for (; i < entries.length; i++) {\n        const entry = entries[i]\n        const height = (entry.target as HTMLElement).offsetHeight\n\n        if (height > 0) {\n          const index = elementsCache.get(entry.target)\n\n          if (index !== void 0) {\n            const position = positioner.get(index)\n\n            if (position !== void 0 && height !== position.height)\n              updates.push(index, height)\n          }\n        }\n      }\n\n      if (updates.length > 0) {\n        // Updates the size/positions of the cell with the resize\n        // observer updates\n        positioner.update(updates)\n        updater(updates)\n      }\n    }) as ResizeObserverCallback)\n\n    const ro = new ResizeObserver(handleEntries)\n    // Overrides the original disconnect to include cancelling handling the entries.\n    // Ideally this would be its own method but that would result in a breaking\n    // change.\n    const disconnect = ro.disconnect.bind(ro)\n    ro.disconnect = () => {\n      disconnect()\n      handleEntries.cancel()\n    }\n\n    return ro\n  }\n)\n","type Color = 0 | 1 | 2\nconst RED = 0\nconst BLACK = 1\nconst NIL = 2\n\nconst DELETE = 0\nconst KEEP = 1\n\ntype ListNode = {\n  index: number\n  high: number\n  next: ListNode | null\n}\n\ninterface TreeNode {\n  max: number\n  low: number\n  high: number\n  // color\n  C: Color\n  // P\n  P: TreeNode\n  // right\n  R: TreeNode\n  // left\n  L: TreeNode\n  list: ListNode\n}\n\ninterface Tree {\n  root: TreeNode\n  size: number\n}\n\nfunction addInterval(treeNode: TreeNode, high: number, index: number): boolean {\n  let node: ListNode | null = treeNode.list\n  let prevNode: ListNode | undefined\n\n  while (node) {\n    if (node.index === index) return false\n    if (high > node.high) break\n    prevNode = node\n    node = node.next\n  }\n\n  if (!prevNode) treeNode.list = {index, high, next: node}\n  if (prevNode) prevNode.next = {index, high, next: prevNode.next}\n\n  return true\n}\n\nfunction removeInterval(treeNode: TreeNode, index: number) {\n  let node: ListNode | null = treeNode.list\n  if (node.index === index) {\n    if (node.next === null) return DELETE\n    treeNode.list = node.next\n    return KEEP\n  }\n\n  let prevNode: ListNode | undefined = node\n  node = node.next\n\n  while (node !== null) {\n    if (node.index === index) {\n      prevNode.next = node.next\n      return KEEP\n    }\n    prevNode = node\n    node = node.next\n  }\n}\n\nconst NULL_NODE: TreeNode = {\n  low: 0,\n  max: 0,\n  high: 0,\n  C: NIL,\n  // @ts-ignore\n  P: undefined,\n  // @ts-ignore\n  R: undefined,\n  // @ts-ignore\n  L: undefined,\n  // @ts-ignore\n  list: undefined,\n}\n\nNULL_NODE.P = NULL_NODE\nNULL_NODE.L = NULL_NODE\nNULL_NODE.R = NULL_NODE\n\nfunction updateMax(node: TreeNode) {\n  const max = node.high\n  if (node.L === NULL_NODE && node.R === NULL_NODE) node.max = max\n  else if (node.L === NULL_NODE) node.max = Math.max(node.R.max, max)\n  else if (node.R === NULL_NODE) node.max = Math.max(node.L.max, max)\n  else node.max = Math.max(Math.max(node.L.max, node.R.max), max)\n}\n\nfunction updateMaxUp(node: TreeNode) {\n  let x = node\n\n  while (x.P !== NULL_NODE) {\n    updateMax(x.P)\n    x = x.P\n  }\n}\n\nfunction rotateLeft(tree: Tree, x: TreeNode) {\n  if (x.R === NULL_NODE) return\n  const y = x.R\n  x.R = y.L\n  if (y.L !== NULL_NODE) y.L.P = x\n  y.P = x.P\n\n  if (x.P === NULL_NODE) tree.root = y\n  else {\n    if (x === x.P.L) x.P.L = y\n    else x.P.R = y\n  }\n\n  y.L = x\n  x.P = y\n\n  updateMax(x)\n  updateMax(y)\n}\n\nfunction rotateRight(tree: Tree, x: TreeNode) {\n  if (x.L === NULL_NODE) return\n  const y = x.L\n  x.L = y.R\n  if (y.R !== NULL_NODE) y.R.P = x\n  y.P = x.P\n\n  if (x.P === NULL_NODE) tree.root = y\n  else {\n    if (x === x.P.R) x.P.R = y\n    else x.P.L = y\n  }\n\n  y.R = x\n  x.P = y\n\n  updateMax(x)\n  updateMax(y)\n}\n\nfunction replaceNode(tree: Tree, x: TreeNode, y: TreeNode) {\n  if (x.P === NULL_NODE) tree.root = y\n  else if (x === x.P.L) x.P.L = y\n  else x.P.R = y\n  y.P = x.P\n}\n\nfunction fixRemove(tree: Tree, x: TreeNode) {\n  let w\n\n  while (x !== NULL_NODE && x.C === BLACK) {\n    if (x === x.P.L) {\n      w = x.P.R\n\n      if (w.C === RED) {\n        w.C = BLACK\n        x.P.C = RED\n        rotateLeft(tree, x.P)\n        w = x.P.R\n      }\n\n      if (w.L.C === BLACK && w.R.C === BLACK) {\n        w.C = RED\n        x = x.P\n      } else {\n        if (w.R.C === BLACK) {\n          w.L.C = BLACK\n          w.C = RED\n          rotateRight(tree, w)\n          w = x.P.R\n        }\n\n        w.C = x.P.C\n        x.P.C = BLACK\n        w.R.C = BLACK\n        rotateLeft(tree, x.P)\n        x = tree.root\n      }\n    } else {\n      w = x.P.L\n\n      if (w.C === RED) {\n        w.C = BLACK\n        x.P.C = RED\n        rotateRight(tree, x.P)\n        w = x.P.L\n      }\n\n      if (w.R.C === BLACK && w.L.C === BLACK) {\n        w.C = RED\n        x = x.P\n      } else {\n        if (w.L.C === BLACK) {\n          w.R.C = BLACK\n          w.C = RED\n          rotateLeft(tree, w)\n          w = x.P.L\n        }\n\n        w.C = x.P.C\n        x.P.C = BLACK\n        w.L.C = BLACK\n        rotateRight(tree, x.P)\n        x = tree.root\n      }\n    }\n  }\n\n  x.C = BLACK\n}\n\nfunction minimumTree(x: TreeNode) {\n  while (x.L !== NULL_NODE) x = x.L\n  return x\n}\n\nfunction fixInsert(tree: Tree, z: TreeNode) {\n  let y: TreeNode\n  while (z.P.C === RED) {\n    if (z.P === z.P.P.L) {\n      y = z.P.P.R\n\n      if (y.C === RED) {\n        z.P.C = BLACK\n        y.C = BLACK\n        z.P.P.C = RED\n        z = z.P.P\n      } else {\n        if (z === z.P.R) {\n          z = z.P\n          rotateLeft(tree, z)\n        }\n\n        z.P.C = BLACK\n        z.P.P.C = RED\n        rotateRight(tree, z.P.P)\n      }\n    } else {\n      y = z.P.P.L\n\n      if (y.C === RED) {\n        z.P.C = BLACK\n        y.C = BLACK\n        z.P.P.C = RED\n        z = z.P.P\n      } else {\n        if (z === z.P.L) {\n          z = z.P\n          rotateRight(tree, z)\n        }\n\n        z.P.C = BLACK\n        z.P.P.C = RED\n        rotateLeft(tree, z.P.P)\n      }\n    }\n  }\n  tree.root.C = BLACK\n}\n\nexport interface IIntervalTree {\n  insert(low: number, high: number, index: number): void\n  remove(index: number): void\n  search(\n    low: number,\n    high: number,\n    callback: (index: number, low: number) => any\n  ): void\n  size: number\n}\n\nexport function createIntervalTree(): IIntervalTree {\n  const tree = {\n    root: NULL_NODE,\n    size: 0,\n  }\n  // we know these indexes are a consistent, safe way to make look ups\n  // for our case so it's a solid O(1) alternative to\n  // the O(log n) searchNode() in typical interval trees\n  const indexMap: Record<number, TreeNode> = {}\n\n  return {\n    insert(low, high, index) {\n      let x: TreeNode = tree.root\n      let y: TreeNode = NULL_NODE\n\n      while (x !== NULL_NODE) {\n        y = x\n        if (low === y.low) break\n        if (low < x.low) x = x.L\n        else x = x.R\n      }\n\n      if (low === y.low && y !== NULL_NODE) {\n        if (!addInterval(y, high, index)) return\n        y.high = Math.max(y.high, high)\n        updateMax(y)\n        updateMaxUp(y)\n        indexMap[index] = y\n        tree.size++\n        return\n      }\n\n      const z: TreeNode = {\n        low,\n        high,\n        max: high,\n        C: RED,\n        P: y,\n        L: NULL_NODE,\n        R: NULL_NODE,\n        list: {index, high, next: null},\n      }\n\n      if (y === NULL_NODE) {\n        tree.root = z\n      } else {\n        if (z.low < y.low) y.L = z\n        else y.R = z\n        updateMaxUp(z)\n      }\n\n      fixInsert(tree, z)\n      indexMap[index] = z\n      tree.size++\n    },\n\n    remove(index) {\n      const z = indexMap[index]\n      if (z === void 0) return\n      delete indexMap[index]\n\n      const intervalResult = removeInterval(z, index)\n      if (intervalResult === void 0) return\n      if (intervalResult === KEEP) {\n        z.high = z.list.high\n        updateMax(z)\n        updateMaxUp(z)\n        tree.size--\n        return\n      }\n\n      let y = z\n      let originalYColor = y.C\n      let x: TreeNode\n\n      if (z.L === NULL_NODE) {\n        x = z.R\n        replaceNode(tree, z, z.R)\n      } else if (z.R === NULL_NODE) {\n        x = z.L\n        replaceNode(tree, z, z.L)\n      } else {\n        y = minimumTree(z.R)\n        originalYColor = y.C\n        x = y.R\n\n        if (y.P === z) {\n          x.P = y\n        } else {\n          replaceNode(tree, y, y.R)\n          y.R = z.R\n          y.R.P = y\n        }\n\n        replaceNode(tree, z, y)\n        y.L = z.L\n        y.L.P = y\n        y.C = z.C\n      }\n\n      updateMax(x)\n      updateMaxUp(x)\n\n      if (originalYColor === BLACK) fixRemove(tree, x)\n      tree.size--\n    },\n\n    search(low, high, callback) {\n      const stack = [tree.root]\n      while (stack.length !== 0) {\n        const node = stack.pop() as TreeNode\n        if (node === NULL_NODE || low > node.max) continue\n        if (node.L !== NULL_NODE) stack.push(node.L)\n        if (node.R !== NULL_NODE) stack.push(node.R)\n        if (node.low <= high && node.high >= low) {\n          let curr: ListNode | null = node.list\n          while (curr !== null) {\n            if (curr.high >= low) callback(curr.index, node.low)\n            curr = curr.next\n          }\n        }\n      }\n    },\n\n    get size() {\n      return tree.size\n    },\n  }\n}\n","import * as React from 'react'\nimport {createIntervalTree} from './interval-tree'\n\n/**\n * This hook creates the grid cell positioner and cache required by `useMasonry()`. This is\n * the meat of the grid's layout algorithm, determining which cells to render at a given scroll\n * position, as well as where to place new items in the grid.\n *\n * @param options Properties that determine the number of columns in the grid, as well\n *  as their widths.\n * @param deps This hook will create a new positioner, clearing all existing cached positions,\n *  whenever the dependencies in this list change.\n */\nexport function usePositioner(\n  {\n    width,\n    columnWidth = 200,\n    columnGutter = 0,\n    columnCount,\n  }: UsePositionerOptions,\n  deps: React.DependencyList = emptyArr\n): Positioner {\n  const initPositioner = (): Positioner => {\n    const [computedColumnWidth, computedColumnCount] = getColumns(\n      width,\n      columnWidth,\n      columnGutter,\n      columnCount\n    )\n    return createPositioner(\n      computedColumnCount,\n      computedColumnWidth,\n      columnGutter\n    )\n  }\n  const positionerRef = React.useRef<Positioner>()\n  if (positionerRef.current === undefined)\n    positionerRef.current = initPositioner()\n\n  const prevDeps = React.useRef(deps)\n  const opts = [width, columnWidth, columnGutter, columnCount]\n  const prevOpts = React.useRef(opts)\n  const optsChanged = !opts.every((item, i) => prevOpts.current[i] === item)\n\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n    if (deps.length !== prevDeps.current.length) {\n      throw new Error(\n        'usePositioner(): The length of your dependencies array changed.'\n      )\n    }\n  }\n\n  // Create a new positioner when the dependencies or sizes change\n  // Thanks to https://github.com/khmm12 for pointing this out\n  // https://github.com/jaredLunde/masonic/pull/41\n  if (optsChanged || !deps.every((item, i) => prevDeps.current[i] === item)) {\n    const prevPositioner = positionerRef.current\n    const positioner = initPositioner()\n    prevDeps.current = deps\n    prevOpts.current = opts\n\n    if (optsChanged) {\n      const cacheSize = prevPositioner.size()\n      for (let index = 0; index < cacheSize; index++) {\n        const pos = prevPositioner.get(index)\n        positioner.set(index, pos !== void 0 ? pos.height : 0)\n      }\n    }\n\n    positionerRef.current = positioner\n  }\n\n  return positionerRef.current\n}\n\nexport interface UsePositionerOptions {\n  /**\n   * The width of the container you're rendering the grid within, i.e. the container\n   * element's `element.offsetWidth`\n   */\n  width: number\n  /**\n   * The minimum column width. The `usePositioner()` hook will automatically size the\n   * columns to fill their container based upon the `columnWidth` and `columnGutter` values.\n   * It will never render anything smaller than this width unless its container itself is\n   * smaller than its value. This property is optional if you're using a static `columnCount`.\n   * @default 200\n   */\n  columnWidth?: number\n  /**\n   * This sets the vertical and horizontal space between grid cells in pixels.\n   */\n  columnGutter?: number\n  /**\n   * By default, `usePositioner()` derives the column count from the `columnWidth`, `columnGutter`,\n   * and `width` props. However, in some situations it is nice to be able to override that behavior\n   * (e.g. creating a `List` component).\n   */\n  columnCount?: number\n}\n\n/**\n * Creates a cell positioner for the `useMasonry()` hook. The `usePositioner()` hook uses\n * this utility under the hood.\n *\n * @param columnCount The number of columns in the grid\n * @param columnWidth The width of each column in the grid\n * @param columnGutter The amount of horizontal and vertical space in pixels to render\n *  between each grid item.\n */\nexport const createPositioner = (\n  columnCount: number,\n  columnWidth: number,\n  columnGutter = 0\n): Positioner => {\n  // O(log(n)) lookup of cells to render for a given viewport size\n  // Store tops and bottoms of each cell for fast intersection lookup.\n  const intervalTree = createIntervalTree()\n  // Track the height of each column.\n  // Layout algorithm below always inserts into the shortest column.\n  const columnHeights: number[] = new Array(columnCount)\n  // Used for O(1) item access\n  const items: PositionerItem[] = []\n  // Tracks the item indexes within an individual column\n  const columnItems: number[][] = new Array(columnCount)\n\n  for (let i = 0; i < columnCount; i++) {\n    columnHeights[i] = 0\n    columnItems[i] = []\n  }\n\n  return {\n    columnCount,\n    columnWidth,\n    set: (index, height = 0) => {\n      let column = 0\n\n      // finds the shortest column and uses it\n      for (let i = 1; i < columnHeights.length; i++) {\n        if (columnHeights[i] < columnHeights[column]) column = i\n      }\n\n      const top = columnHeights[column] || 0\n      columnHeights[column] = top + height + columnGutter\n      columnItems[column].push(index)\n      items[index] = {\n        left: column * (columnWidth + columnGutter),\n        top,\n        height,\n        column,\n      }\n      intervalTree.insert(top, top + height, index)\n    },\n    get: (index) => items[index],\n    // This only updates items in the specific columns that have changed, on and after the\n    // specific items that have changed\n    update: (updates) => {\n      const columns: number[] = new Array(columnCount)\n      let i = 0,\n        j = 0\n\n      // determines which columns have items that changed, as well as the minimum index\n      // changed in that column, as all items after that index will have their positions\n      // affected by the change\n      for (; i < updates.length - 1; i++) {\n        const index = updates[i]\n        const item = items[index]\n        item.height = updates[++i]\n        intervalTree.remove(index)\n        intervalTree.insert(item.top, item.top + item.height, index)\n        columns[item.column] =\n          columns[item.column] === void 0\n            ? index\n            : Math.min(index, columns[item.column])\n      }\n\n      for (i = 0; i < columns.length; i++) {\n        // bails out if the column didn't change\n        if (columns[i] === void 0) continue\n        const itemsInColumn = columnItems[i]\n        // the index order is sorted with certainty so binary search is a great solution\n        // here as opposed to Array.indexOf()\n        const startIndex = binarySearch(itemsInColumn, columns[i])\n        const index = columnItems[i][startIndex]\n        const startItem = items[index]\n        columnHeights[i] = startItem.top + startItem.height + columnGutter\n\n        for (j = startIndex + 1; j < itemsInColumn.length; j++) {\n          const index = itemsInColumn[j]\n          const item = items[index]\n          item.top = columnHeights[i]\n          columnHeights[i] = item.top + item.height + columnGutter\n          intervalTree.remove(index)\n          intervalTree.insert(item.top, item.top + item.height, index)\n        }\n      }\n    },\n    // Render all cells visible within the viewport range defined.\n    range: (lo, hi, renderCallback) =>\n      intervalTree.search(lo, hi, (index, top) =>\n        renderCallback(index, items[index].left, top)\n      ),\n    estimateHeight: (itemCount, defaultItemHeight): number => {\n      const tallestColumn = Math.max(0, Math.max.apply(null, columnHeights))\n\n      return itemCount === intervalTree.size\n        ? tallestColumn\n        : tallestColumn +\n            Math.ceil((itemCount - intervalTree.size) / columnCount) *\n              defaultItemHeight\n    },\n    shortestColumn: () => {\n      if (columnHeights.length > 1) return Math.min.apply(null, columnHeights)\n      return columnHeights[0] || 0\n    },\n    size(): number {\n      return intervalTree.size\n    },\n  }\n}\n\nexport interface Positioner {\n  /**\n   * The number of columns in the grid\n   */\n  columnCount: number\n  /**\n   * The width of each column in the grid\n   */\n  columnWidth: number\n  /**\n   * Sets the position for the cell at `index` based upon the cell's height\n   */\n  set: (index: number, height: number) => void\n  /**\n   * Gets the `PositionerItem` for the cell at `index`\n   */\n  get: (index: number) => PositionerItem | undefined\n  /**\n   * Updates cells based on their indexes and heights\n   * positioner.update([index, height, index, height, index, height...])\n   */\n  update: (updates: number[]) => void\n  /**\n   * Searches the interval tree for grid cells with a `top` value in\n   * betwen `lo` and `hi` and invokes the callback for each item that\n   * is discovered\n   */\n  range: (\n    lo: number,\n    hi: number,\n    renderCallback: (index: number, left: number, top: number) => void\n  ) => void\n  /**\n   * Returns the number of grid cells in the cache\n   */\n\n  size: () => number\n  /**\n   * Estimates the total height of the grid\n   */\n\n  estimateHeight: (itemCount: number, defaultItemHeight: number) => number\n  /**\n   * Returns the height of the shortest column in the grid\n   */\n\n  shortestColumn: () => number\n}\n\nexport interface PositionerItem {\n  /**\n   * This is how far from the top edge of the grid container in pixels the\n   * item is placed\n   */\n  top: number\n  /**\n   * This is how far from the left edge of the grid container in pixels the\n   * item is placed\n   */\n  left: number\n  /**\n   * This is the height of the grid cell\n   */\n  height: number\n  /**\n   * This is the column number containing the grid cell\n   */\n  column: number\n}\n\n/* istanbul ignore next */\nconst binarySearch = (a: number[], y: number): number => {\n  let l = 0\n  let h = a.length - 1\n\n  while (l <= h) {\n    const m = (l + h) >>> 1\n    const x = a[m]\n    if (x === y) return m\n    else if (x <= y) l = m + 1\n    else h = m - 1\n  }\n\n  return -1\n}\n\nconst getColumns = (\n  width = 0,\n  minimumWidth = 0,\n  gutter = 8,\n  columnCount?: number\n): [number, number] => {\n  columnCount = columnCount || Math.floor(width / (minimumWidth + gutter)) || 1\n  const columnWidth = Math.floor(\n    (width - gutter * (columnCount - 1)) / columnCount\n  )\n  return [columnWidth, columnCount]\n}\n\nconst emptyArr: [] = []\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\nimport useEvent from '@react-hook/event'\nimport {useThrottleCallback} from '@react-hook/throttle'\nimport type {Positioner, PositionerItem} from './use-positioner'\n\n/**\n * A hook that creates a callback for scrolling to a specific index in\n * the \"items\" array.\n *\n * @param positioner A positioner created by the `usePositioner()` hook\n * @param options Configuration options\n */\nexport function useScrollToIndex(\n  positioner: Positioner,\n  options: UseScrollToIndexOptions\n) {\n  const {\n    align = 'top',\n    element = typeof window !== 'undefined' && window,\n    offset = 0,\n    height = typeof window !== 'undefined' ? window.innerHeight : 0,\n  } = options\n  const latestOptions = useLatest({\n    positioner,\n    element,\n    align,\n    offset,\n    height,\n  } as const)\n  const getTarget = React.useRef(() => {\n    const latestElement = latestOptions.current.element\n    return latestElement && 'current' in latestElement\n      ? latestElement.current\n      : latestElement\n  }).current\n  const [state, dispatch] = React.useReducer(\n    (\n      state: {\n        position: PositionerItem | undefined\n        index: number | undefined\n        prevTop: number | undefined\n      },\n      action:\n        | {type: 'scrollToIndex'; value: number | undefined}\n        | {type: 'setPosition'; value: PositionerItem | undefined}\n        | {type: 'setPrevTop'; value: number | undefined}\n        | {type: 'reset'}\n    ) => {\n      const nextState = {\n        position: state.position,\n        index: state.index,\n        prevTop: state.prevTop,\n      }\n\n      /* istanbul ignore next */\n      if (action.type === 'scrollToIndex') {\n        return {\n          position: latestOptions.current.positioner.get(action.value ?? -1),\n          index: action.value,\n          prevTop: void 0,\n        }\n      } else if (action.type === 'setPosition') {\n        nextState.position = action.value\n      } else if (action.type === 'setPrevTop') {\n        nextState.prevTop = action.value\n      } else if (action.type === 'reset') {\n        return defaultState\n      }\n\n      return nextState\n    },\n    defaultState\n  )\n  const throttledDispatch = useThrottleCallback(dispatch, 15)\n\n  // If we find the position along the way we can immediately take off\n  // to the correct spot.\n  useEvent(getTarget() as Window, 'scroll', () => {\n    if (!state.position && state.index) {\n      const position = latestOptions.current.positioner.get(state.index)\n\n      if (position) {\n        dispatch({type: 'setPosition', value: position})\n      }\n    }\n  })\n\n  // If the top changes out from under us in the case of dynamic cells, we\n  // want to keep following it.\n  const currentTop =\n    state.index !== void 0 &&\n    latestOptions.current.positioner.get(state.index)?.top\n\n  React.useEffect(() => {\n    const target = getTarget()\n    if (!target) return\n    const {height, align, offset, positioner} = latestOptions.current\n\n    if (state.position) {\n      let scrollTop = state.position.top\n\n      if (align === 'bottom') {\n        scrollTop = scrollTop - height + state.position.height\n      } else if (align === 'center') {\n        scrollTop -= (height - state.position.height) / 2\n      }\n\n      target.scrollTo(0, Math.max(0, (scrollTop += offset)))\n      // Resets state after 400ms, an arbitrary time I determined to be\n      // still visually pleasing if there is a slow network reply in dynamic\n      // cells\n      let didUnsubscribe = false\n      const timeout = setTimeout(\n        () => !didUnsubscribe && dispatch({type: 'reset'}),\n        400\n      )\n      return () => {\n        didUnsubscribe = true\n        clearTimeout(timeout)\n      }\n    } else if (state.index !== void 0) {\n      // Estimates the top based upon the average height of current cells\n      let estimatedTop =\n        (positioner.shortestColumn() / positioner.size()) * state.index\n      if (state.prevTop)\n        estimatedTop = Math.max(estimatedTop, state.prevTop + height)\n      target.scrollTo(0, estimatedTop)\n      throttledDispatch({type: 'setPrevTop', value: estimatedTop})\n    }\n  }, [currentTop, state, latestOptions, getTarget, throttledDispatch])\n\n  return React.useRef((index: number) => {\n    dispatch({type: 'scrollToIndex', value: index})\n  }).current\n}\n\nconst defaultState = {\n  index: void 0,\n  position: void 0,\n  prevTop: void 0,\n} as const\n\nexport type UseScrollToIndexOptions = {\n  /**\n   * The window element or a React ref for the window element. That is,\n   * this is the grid container.\n   * @default window\n   */\n  element?: Window | HTMLElement | React.RefObject<HTMLElement> | null\n  /**\n   * Sets the vertical alignment of the cell within the grid container.\n   * @default \"top\"\n   */\n  align?: 'center' | 'top' | 'bottom'\n  /**\n   * The height of the grid.\n   * @default window.innerHeight\n   */\n  height?: number\n  /**\n   * The vertical space in pixels between the top of the grid container and the top\n   * of the window.\n   * @default 0\n   */\n  offset?: number\n}\n","import * as React from 'react'\nimport {useWindowSize} from '@react-hook/window-size'\nimport {MasonryScroller} from './masonry-scroller'\nimport type {MasonryScrollerProps} from './masonry-scroller'\nimport {useContainerPosition} from './use-container-position'\nimport {useResizeObserver} from './use-resize-observer'\nimport {usePositioner} from './use-positioner'\nimport type {UsePositionerOptions} from './use-positioner'\nimport {useScrollToIndex} from './use-scroll-to-index'\nimport type {UseScrollToIndexOptions} from './use-scroll-to-index'\n\n/**\n * A \"batteries included\" masonry grid which includes all of the implementation details below. This component is the\n * easiest way to get off and running in your app, before switching to more advanced implementations, if necessary.\n * It will change its column count to fit its container's width and will decide how many rows to render based upon\n * the height of the browser `window`.\n */\nexport function Masonry<Item>(props: MasonryProps<Item>) {\n  const containerRef = React.useRef<null | HTMLElement>(null)\n  const windowSize = useWindowSize({\n    initialWidth: props.ssrWidth,\n    initialHeight: props.ssrHeight,\n  })\n  const containerPos = useContainerPosition(containerRef, windowSize)\n  const nextProps = Object.assign(\n    {\n      offset: containerPos.offset,\n      width: containerPos.width || windowSize[0],\n      height: windowSize[1],\n      containerRef,\n    },\n    props\n  ) as any\n  nextProps.positioner = usePositioner(nextProps)\n  nextProps.resizeObserver = useResizeObserver(nextProps.positioner)\n  const scrollToIndex = useScrollToIndex(nextProps.positioner, {\n    height: nextProps.height,\n    offset: containerPos.offset,\n    align:\n      typeof props.scrollToIndex === 'object'\n        ? props.scrollToIndex.align\n        : void 0,\n  })\n  const index =\n    props.scrollToIndex &&\n    (typeof props.scrollToIndex === 'number'\n      ? props.scrollToIndex\n      : props.scrollToIndex.index)\n\n  React.useEffect(() => {\n    if (index !== void 0) scrollToIndex(index)\n  }, [index, scrollToIndex])\n\n  return React.createElement(MasonryScroller, nextProps)\n}\n\nexport interface MasonryProps<Item>\n  extends Omit<\n      MasonryScrollerProps<Item>,\n      'offset' | 'width' | 'height' | 'containerRef' | 'positioner'\n    >,\n    Pick<UsePositionerOptions, 'columnWidth' | 'columnGutter' | 'columnCount'> {\n  /**\n   * Scrolls to a given index within the grid. The grid will re-scroll\n   * any time the index changes.\n   */\n  scrollToIndex?:\n    | number\n    | {\n        index: number\n        align: UseScrollToIndexOptions['align']\n      }\n  /**\n   * This is the width that will be used for the browser `window` when rendering this component in SSR.\n   * This prop isn't relevant for client-side only apps.\n   */\n  ssrWidth?: number\n  /**\n   * This is the height that will be used for the browser `window` when rendering this component in SSR.\n   * This prop isn't relevant for client-side only apps.\n   */\n  ssrHeight?: number\n  /**\n   * This determines how often (in frames per second) to update the scroll position of the\n   * browser `window` in state, and as a result the rate the masonry grid recalculates its visible cells.\n   * The default value of `12` has been very reasonable in my own testing, but if you have particularly\n   * heavy `render` components it may be prudent to reduce this number.\n   * @default 12\n   */\n  scrollFps?: number\n}\n\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n  Masonry.displayName = 'Masonry'\n}\n","import * as React from 'react'\nimport {Masonry} from './masonry'\nimport type {MasonryProps} from './masonry'\n\n/**\n * This is just a single-column `<Masonry>` component with `rowGutter` prop instead of\n * a `columnGutter` prop.\n */\nexport function List<Item>(props: ListProps<Item>) {\n  return (\n    <Masonry<Item>\n      role='list'\n      columnGutter={props.rowGutter}\n      columnCount={1}\n      columnWidth={1}\n      {...props}\n    />\n  )\n}\n\nexport interface ListProps<Item>\n  extends Omit<\n    MasonryProps<Item>,\n    'columGutter' | 'columnCount' | 'columnWidth'\n  > {\n  /**\n   * The amount of vertical space in pixels to add between the list cells.\n   * @default 0\n   */\n  rowGutter?: number\n}\n\nif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n  List.displayName = 'List'\n}\n","import * as React from 'react'\nimport useLatest from '@react-hook/latest'\n\n/**\n * A utility hook for seamlessly adding infinite scroll behavior to the `useMasonry()` hook. This\n * hook invokes a callback each time the last rendered index surpasses the total number of items\n * in your items array or the number defined in the `totalItems` option.\n *\n * @param loadMoreItems This callback is invoked when more rows must be loaded. It will be used to\n *  determine when to refresh the list with the newly-loaded data. This callback may be called multiple\n *  times in reaction to a single scroll event, so it's important to memoize its arguments. If you're\n *  creating this callback inside of a functional component, make sure you wrap it in `React.useCallback()`,\n *  as well.\n * @param options\n */\nexport function useInfiniteLoader<Item, T extends LoadMoreItemsCallback<Item>>(\n  loadMoreItems: T,\n  options: UseInfiniteLoaderOptions<Item> = emptyObj\n): LoadMoreItemsCallback<Item> {\n  const {\n    isItemLoaded,\n    minimumBatchSize = 16,\n    threshold = 16,\n    totalItems = 9e9,\n  } = options\n  const storedLoadMoreItems = useLatest(loadMoreItems)\n  const storedIsItemLoaded = useLatest(isItemLoaded)\n\n  return React.useCallback(\n    (startIndex, stopIndex, items) => {\n      const unloadedRanges = scanForUnloadedRanges(\n        storedIsItemLoaded.current,\n        minimumBatchSize,\n        items,\n        totalItems,\n        Math.max(0, startIndex - threshold),\n        Math.min(totalItems - 1, (stopIndex || 0) + threshold)\n      )\n      // The user is responsible for memoizing their loadMoreItems() function\n      // because we don't want to make assumptions about how they want to deal\n      // with `items`\n      for (let i = 0; i < unloadedRanges.length - 1; ++i)\n        storedLoadMoreItems.current(\n          unloadedRanges[i],\n          unloadedRanges[++i],\n          items\n        )\n    },\n    [\n      totalItems,\n      minimumBatchSize,\n      threshold,\n      storedLoadMoreItems,\n      storedIsItemLoaded,\n    ]\n  )\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nfunction scanForUnloadedRanges<Item>(\n  isItemLoaded: UseInfiniteLoaderOptions<\n    Item\n  >['isItemLoaded'] = defaultIsItemLoaded,\n  minimumBatchSize: UseInfiniteLoaderOptions<Item>['minimumBatchSize'] = 16,\n  items: any[],\n  totalItems: UseInfiniteLoaderOptions<Item>['totalItems'] = 9e9,\n  startIndex: number,\n  stopIndex: number\n): number[] {\n  const unloadedRanges: number[] = []\n  let rangeStartIndex: number | undefined,\n    rangeStopIndex: number | undefined,\n    index = startIndex\n\n  /* istanbul ignore next */\n  for (; index <= stopIndex; index++) {\n    if (!isItemLoaded(index, items)) {\n      rangeStopIndex = index\n      if (rangeStartIndex === void 0) rangeStartIndex = index\n    } else if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n      unloadedRanges.push(rangeStartIndex, rangeStopIndex)\n      rangeStartIndex = rangeStopIndex = void 0\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't run out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStartIndex !== void 0 && rangeStopIndex !== void 0) {\n    const potentialStopIndex = Math.min(\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\n      totalItems - 1\n    )\n\n    /* istanbul ignore next */\n    for (index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isItemLoaded(index, items)) {\n        rangeStopIndex = index\n      } else {\n        break\n      }\n    }\n\n    unloadedRanges.push(rangeStartIndex, rangeStopIndex)\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  /* istanbul ignore next */\n  if (unloadedRanges.length) {\n    let firstUnloadedStart = unloadedRanges[0]\n    const firstUnloadedStop = unloadedRanges[1]\n\n    while (\n      firstUnloadedStop - firstUnloadedStart + 1 < minimumBatchSize &&\n      firstUnloadedStart > 0\n    ) {\n      const index = firstUnloadedStart - 1\n\n      if (!isItemLoaded(index, items)) {\n        unloadedRanges[0] = firstUnloadedStart = index\n      } else {\n        break\n      }\n    }\n  }\n\n  return unloadedRanges\n}\n\nconst defaultIsItemLoaded = <Item>(index: number, items: Item[]): boolean =>\n  items[index] !== void 0\n\nexport interface UseInfiniteLoaderOptions<Item> {\n  /**\n   *  A callback responsible for determining the loaded state of each item. Should return `true`\n   * if the item has already been loaded and `false` if not.\n   * @default (index: number, items: any[]) => boolean\n   */\n  isItemLoaded?: (index: number, items: Item[]) => boolean\n  /**\n   * The minimum number of new items to be loaded at a time.  This property can be used to\n   * batch requests and reduce HTTP requests.\n   * @default 16\n   */\n  minimumBatchSize?: number\n  /**\n   * The threshold at which to pre-fetch data. A threshold X means that new data should start\n   * loading when a user scrolls within X cells of the end of your `items` array.\n   * @default 16\n   */\n  threshold?: number\n  /**\n   * The total number of items you'll need to eventually load (if known). This can\n   * be arbitrarily high if not known.\n   * @default 9e9\n   */\n  totalItems?: number\n}\n\nexport type LoadMoreItemsCallback<Item> = (\n  startIndex: number,\n  stopIndex: number,\n  items: Item[]\n) => any\n\nconst emptyObj = {}\n","export const elementsCache: WeakMap<Element, number> = new WeakMap()\n"],"names":["useScroller","offset","fps","setIsScrolling","scrollTop","useScrollPosition","isScrolling","React","didMount","current","to","requestTimeout","clearRequestTimeout","Math","max","useForceUpdate","setState","emptyObj","useMasonry","stopIndex","positioner","resizeObserver","items","as","ContainerComponent","id","key","className","style","role","tabIndex","containerRef","itemAs","ItemComponent","itemStyle","itemHeightEstimate","itemKey","defaultGetItemKey","overscanBy","height","render","RenderComponent","onRender","startIndex","forceUpdate","setItemRef","getRefSetter","itemCount","length","columnWidth","columnCount","range","estimateHeight","size","shortestColumn","measuredCount","shortestColumnSize","children","itemRole","undefined","storedOnRender","useLatest","rangeEnd","needsFreshBatch","index","left","top","data","phaseTwoStyle","width","writingMode","position","push","__reactCreateElement__","ref","Object","assign","createRenderElement","min","batchSize","ceil","phaseOneStyle","getCachedSize","didEverMount","containerStyle","getContainerStyle","assignUserStyle","_","i","MasonryScroller","props","scrollFps","useContainerPosition","elementRef","deps","emptyArr","containerPosition","setContainerPosition","useLayoutEffect","el","offsetTop","offsetParent","offsetWidth","useResizeObserver","disconnect","createResizeObserver","updateMax","node","high","L","NULL_NODE","R","updateMaxUp","x","P","rotateLeft","tree","y","root","rotateRight","replaceNode","createIntervalTree","indexMap","insert","low","treeNode","prevNode","list","next","addInterval","z","C","fixInsert","remove","intervalResult","removeInterval","originalYColor","minimumTree","w","fixRemove","search","callback","stack","pop","curr","usePositioner","columnGutter","initPositioner","computedColumnWidth","computedColumnCount","getColumns","createPositioner","positionerRef","prevDeps","opts","prevOpts","optsChanged","every","item","prevPositioner","cacheSize","pos","get","set","useScrollToIndex","options","align","element","window","innerHeight","latestOptions","getTarget","latestElement","state","dispatch","action","nextState","prevTop","type","value","defaultState","throttledDispatch","useThrottleCallback","useEvent","currentTop","_latestOptions$curren","target","scrollTo","didUnsubscribe","timeout","setTimeout","clearTimeout","estimatedTop","Masonry","windowSize","useWindowSize","initialWidth","ssrWidth","initialHeight","ssrHeight","containerPos","nextProps","scrollToIndex","List","rowGutter","useInfiniteLoader","loadMoreItems","isItemLoaded","minimumBatchSize","threshold","totalItems","storedLoadMoreItems","storedIsItemLoaded","unloadedRanges","defaultIsItemLoaded","rangeStartIndex","rangeStopIndex","potentialStopIndex","firstUnloadedStart","firstUnloadedStop","scanForUnloadedRanges","elementsCache","WeakMap","trieMemoize","OneKeyMap","memoizeOne","maxWidth","maxHeight","willChange","pointerEvents","cmp2","args","pargs","userStyle","zIndex","visibility","observe","offsetHeight","updater","handleEntries","rafSchd","entries","updates","entry","update","ro","ResizeObserver","bind","cancel","intervalTree","columnHeights","Array","columnItems","column","columns","j","itemsInColumn","binarySearch","startItem","lo","hi","renderCallback","defaultItemHeight","tallestColumn","apply","a","l","h","m","minimumWidth","gutter","floor"],"mappings":"+MAgBO,SAASA,EACdC,EACAC,gBAWIC,EAAe,YAZnBF,IAAAA,EAAS,YACTC,IAAAA,EAAM,QAEAE,EAAYC,EAAkBH,IAC7BI,EAAaH,GAAkBI,EAAe,GAC/CC,EAAWD,EAAa,UAE9BA,EAAgB,KACW,IAArBC,EAASC,SAAeN,EAAe,OACrCO,EAAKC,IAIR,GAAK,IAAOT,UACfM,EAASC,QAAU,EACZ,IAAMG,EAAoBF,IAChC,CAACR,EAAKE,IAEF,CAACA,UAAWS,KAAKC,IAAI,EAAGV,EAAYH,GAASK,YAAAA,GCjC/C,SAASS,QACRC,EAAWT,EAAeU,GAAU,UACnCV,EAAa,IAAMS,EAAS,KAAKP,QCUnC,SAASS,SA6BVC,GA7B4BC,WAEhCA,EAFgCC,eAGhCA,EAHgCC,MAKhCA,EAEAC,GAAIC,EAAqB,MAPOC,GAQhCA,EARgCC,IAShCA,EATgCC,UAUhCA,EAVgCC,MAWhCA,EAXgCC,KAYhCA,EAAO,OAZyBC,SAahCA,EAAW,EAbqBC,aAchCA,EAEAC,OAAQC,EAAgB,MAhBQC,UAiBhCA,EAjBgCC,mBAkBhCA,EAAqB,IAlBWC,QAmBhCA,EAAUC,EAnBsBC,WAqBhCA,EAAa,EArBmBlC,UAsBhCA,EAtBgCE,YAuBhCA,EAvBgCiC,OAwBhCA,EACAC,OAAQC,EAzBwBC,SA0BhCA,KAEIC,EAAa,EAEXC,EAAc7B,IACd8B,EAAaC,EAAa1B,EAAYC,GACtC0B,EAAYzB,EAAM0B,QAClBC,YACJA,EADIC,YAEJA,EAFIC,MAGJA,EAHIC,eAIJA,EAJIC,KAKJA,EALIC,eAMJA,GACElC,EACEmC,EAAgBF,IAChBG,EAAqBF,IACrBG,EAAiC,GACjCC,EACK,SAAT7B,EAAkB,WAAsB,SAATA,EAAkB,gBAAa8B,EAC1DC,EAAiBC,EAAUnB,GAG3BoB,EAAW1D,GADjBkC,GAAaC,GAEPwB,EACiBD,EAArBN,GAAiDT,EAAhBQ,KAEnCJ,EAIEtC,KAAKC,IAAI,EAAGV,EAAYkC,EAAa,GACrCwB,EACA,CAACE,EAAOC,EAAMC,SACNC,EAAO7C,EAAM0C,GACbtC,EAAMU,EAAQ+B,EAAMH,GACpBI,EAAqC,CACzCF,IAAAA,EACAD,KAAAA,EACAI,MAAOpB,EACPqB,YAAa,gBACbC,SAAU,YAWZd,EAASe,KACPC,EAACxC,GACCP,IAAKA,EACLgD,IAAK7B,EAAWmB,GAChBnC,KAAM6B,EACN9B,MACuB,iBAAdM,GAAwC,OAAdA,EAC7ByC,OAAOC,OAAO,GAAIR,EAAelC,GACjCkC,GAGLS,EAAoBpC,EAAiBuB,EAAOG,EAAMlB,UAIrC,IAAd9B,GACFwB,EAAaqB,EACb7C,EAAY6C,IAEZrB,EAAa9B,KAAKiE,IAAInC,EAAYqB,GAClC7C,EAAYN,KAAKC,IAAIK,EAAW6C,MAKlCD,UACIgB,EAAYlE,KAAKiE,IACrB/B,EAAYQ,EACZ1C,KAAKmE,MACD5E,EAAYkC,EAAakB,GAAsBrB,EAC/Ce,IAIFc,EAAQT,EACN0B,EAAgBC,EAAcjC,GAErBM,EAAgBwB,EAAxBf,EAAmCA,IAAS,KAC3CG,GAAO7C,EAAM0C,GACbtC,GAAMU,EAAQ+B,GAAMH,GAU1BP,EAASe,KACPC,EAACxC,GACCP,IAAKA,GACLgD,IAAK7B,EAAWmB,GAChBnC,KAAM6B,EACN9B,MACuB,iBAAdM,EACHyC,OAAOC,OAAO,GAAIK,EAAe/C,GACjC+C,GAGLJ,EAAoBpC,EAAiBuB,EAAOG,GAAMlB,KAO3D1C,EAAgB,KACwB,mBAA3BqD,EAAenD,cAAwC,IAAdU,GAClDyC,EAAenD,QAAQkC,EAAYxB,EAAWG,GAEhD6D,EAAe,KACd,CAACxC,EAAYxB,EAAWG,EAAOsC,IAGlCrD,EAAgB,KACVwD,GAAiBnB,KAEpB,CAACmB,QAIEqB,GAAiBC,EACrB/E,EACA8C,EAAeL,EAAWZ,WAI1BsC,EAACjD,GACCkD,IAAK3C,EACLL,KAAQA,GAAO,QAAMyD,EACrB1D,GAAIA,EACJI,KAAMA,EACNF,UAAWA,EACXG,SAAUA,EACVF,MACmB,iBAAVA,EACH0D,EAAgBF,GAAgBxD,GAChCwD,GAEN3B,SAAUA,IA6MhB,SAASpB,EAAyBkD,EAASC,UAClCA,ECvYF,SAASC,EAAsBC,OAI9BtF,UAACA,EAADE,YAAYA,GAAeN,EAAY0F,EAAMzF,OAAQyF,EAAMC,kBAI1DzE,EAAiB,CACtBd,UAAAA,EACAE,YAAAA,EACAc,WAAYsE,EAAMtE,WAClBC,eAAgBqE,EAAMrE,eACtBC,MAAOoE,EAAMpE,MACboB,SAAUgD,EAAMhD,SAChBnB,GAAImE,EAAMnE,GACVE,GAAIiE,EAAMjE,GACVE,UAAW+D,EAAM/D,UACjBC,MAAO8D,EAAM9D,MACbC,KAAM6D,EAAM7D,KACZC,SAAU4D,EAAM5D,SAChBC,aAAc2D,EAAM3D,aACpBC,OAAQ0D,EAAM1D,OACdE,UAAWwD,EAAMxD,UACjBC,mBAAoBuD,EAAMvD,mBAC1BC,QAASsD,EAAMtD,QACfE,WAAYoD,EAAMpD,WAClBC,OAAQmD,EAAMnD,OACdC,OAAQkD,EAAMlD,SCrBX,SAASoD,EACdC,EACAC,YAAAA,IAAAA,EAA6BC,OAEtBC,EAAmBC,GAAwB1F,EAEhD,CAACN,OAAQ,EAAGoE,MAAO,WAErB6B,EAAgB,SACRzF,QAACA,GAAWoF,KACF,OAAZpF,EAAkB,KAChBR,EAAS,EACTkG,EAAK1F,KAGPR,GAAUkG,EAAGC,WAAa,EAC1BD,EAAKA,EAAGE,mBACDF,GAGPlG,IAAW+F,EAAkB/F,QAC7BQ,EAAQ6F,cAAgBN,EAAkB3B,OAE1C4B,EAAqB,CACnBhG,OAAAA,EACAoE,MAAO5D,EAAQ6F,gBAKpBR,GAEIE,EChCF,SAASO,EAAkBnF,uBAKJC,EAAemF,iBAJrC5D,EAAc7B,IACdM,EAAiBoF,EAAqBrF,EAAYwB,UAGxDrC,EAAgB,MAAyC,CAACc,IACnDA,ECuET,SAASqF,EAAUC,OACX7F,EAAM6F,EAAKC,KACbD,EAAKE,IAAMC,GAAaH,EAAKI,IAAMD,EAAWH,EAAK7F,IAAMA,EACpD6F,EAAKE,IAAMC,EAAWH,EAAK7F,IAAMD,KAAKC,IAAI6F,EAAKI,EAAEjG,IAAKA,GACtD6F,EAAKI,IAAMD,EAAWH,EAAK7F,IAAMD,KAAKC,IAAI6F,EAAKE,EAAE/F,IAAKA,GAC1D6F,EAAK7F,IAAMD,KAAKC,IAAID,KAAKC,IAAI6F,EAAKE,EAAE/F,IAAK6F,EAAKI,EAAEjG,KAAMA,GAG7D,SAASkG,EAAYL,WACfM,EAAIN,EAEDM,EAAEC,IAAMJ,GACbJ,EAAUO,EAAEC,GACZD,EAAIA,EAAEC,EAIV,SAASC,EAAWC,EAAYH,MAC1BA,EAAEF,IAAMD,OACNO,EAAIJ,EAAEF,EACZE,EAAEF,EAAIM,EAAER,EACJQ,EAAER,IAAMC,IAAWO,EAAER,EAAEK,EAAID,GAC/BI,EAAEH,EAAID,EAAEC,EAEJD,EAAEC,IAAMJ,EAAWM,EAAKE,KAAOD,EAE7BJ,IAAMA,EAAEC,EAAEL,EAAGI,EAAEC,EAAEL,EAAIQ,EACpBJ,EAAEC,EAAEH,EAAIM,EAGfA,EAAER,EAAII,EACNA,EAAEC,EAAIG,EAENX,EAAUO,GACVP,EAAUW,IAGZ,SAASE,EAAYH,EAAYH,MAC3BA,EAAEJ,IAAMC,OACNO,EAAIJ,EAAEJ,EACZI,EAAEJ,EAAIQ,EAAEN,EACJM,EAAEN,IAAMD,IAAWO,EAAEN,EAAEG,EAAID,GAC/BI,EAAEH,EAAID,EAAEC,EAEJD,EAAEC,IAAMJ,EAAWM,EAAKE,KAAOD,EAE7BJ,IAAMA,EAAEC,EAAEH,EAAGE,EAAEC,EAAEH,EAAIM,EACpBJ,EAAEC,EAAEL,EAAIQ,EAGfA,EAAEN,EAAIE,EACNA,EAAEC,EAAIG,EAENX,EAAUO,GACVP,EAAUW,IAGZ,SAASG,EAAYJ,EAAYH,EAAaI,GACxCJ,EAAEC,IAAMJ,EAAWM,EAAKE,KAAOD,EAC1BJ,IAAMA,EAAEC,EAAEL,EAAGI,EAAEC,EAAEL,EAAIQ,EACzBJ,EAAEC,EAAEH,EAAIM,EACbA,EAAEH,EAAID,EAAEC,EA+HH,SAASO,QACRL,EAAO,CACXE,KAAMR,EACNzD,KAAM,GAKFqE,EAAqC,SAEpC,CACLC,OAAOC,EAAKhB,EAAM5C,WACZiD,EAAcG,EAAKE,KACnBD,EAAcP,EAEXG,IAAMH,GAEPc,KADJP,EAAIJ,GACUW,KACGX,EAAbW,EAAMX,EAAEW,IAASX,EAAEJ,EACdI,EAAEF,KAGTa,IAAQP,EAAEO,KAAOP,IAAMP,EAAW,KA3Q5C,SAAqBe,EAAoBjB,EAAc5C,WAEjD8D,EADAnB,EAAwBkB,EAASE,KAG9BpB,GAAM,IACPA,EAAK3C,QAAUA,EAAO,OAAO,KAC7B4C,EAAOD,EAAKC,KAAM,MACtBkB,EAAWnB,EACXA,EAAOA,EAAKqB,YAGTF,IAAUD,EAASE,KAAO,CAAC/D,MAAAA,EAAO4C,KAAAA,EAAMoB,KAAMrB,IAC/CmB,IAAUA,EAASE,KAAO,CAAChE,MAAAA,EAAO4C,KAAAA,EAAMoB,KAAMF,EAASE,OAEpD,EA8PIC,CAAYZ,EAAGT,EAAM5C,GAAQ,cAClCqD,EAAET,KAAO/F,KAAKC,IAAIuG,EAAET,KAAMA,GAC1BF,EAAUW,GACVL,EAAYK,GACZK,EAAS1D,GAASqD,OAClBD,EAAK/D,WAID6E,EAAc,CAClBN,IAAAA,EACAhB,KAAAA,EACA9F,IAAK8F,EACLuB,EA1TI,EA2TJjB,EAAGG,EACHR,EAAGC,EACHC,EAAGD,EACHiB,KAAM,CAAC/D,MAAAA,EAAO4C,KAAAA,EAAMoB,KAAM,OAGxBX,IAAMP,EACRM,EAAKE,KAAOY,GAERA,EAAEN,IAAMP,EAAEO,IAAKP,EAAER,EAAIqB,EACpBb,EAAEN,EAAImB,EACXlB,EAAYkB,IAvGpB,SAAmBd,EAAYc,WACzBb,EAhOM,IAiOHa,EAAEhB,EAAEiB,GACLD,EAAEhB,IAAMgB,EAAEhB,EAAEA,EAAEL,EAlOV,KAmONQ,EAAIa,EAAEhB,EAAEA,EAAEH,GAEJoB,GACJD,EAAEhB,EAAEiB,EArOE,EAsONd,EAAEc,EAtOI,EAuOND,EAAEhB,EAAEA,EAAEiB,EAxOF,EAyOJD,EAAIA,EAAEhB,EAAEA,IAEJgB,IAAMA,EAAEhB,EAAEH,GAEZI,EAAWC,EADXc,EAAIA,EAAEhB,GAIRgB,EAAEhB,EAAEiB,EA/OE,EAgPND,EAAEhB,EAAEA,EAAEiB,EAjPF,EAkPJZ,EAAYH,EAAMc,EAAEhB,EAAEA,IAlPlB,KAqPNG,EAAIa,EAAEhB,EAAEA,EAAEL,GAEJsB,GACJD,EAAEhB,EAAEiB,EAvPE,EAwPNd,EAAEc,EAxPI,EAyPND,EAAEhB,EAAEA,EAAEiB,EA1PF,EA2PJD,EAAIA,EAAEhB,EAAEA,IAEJgB,IAAMA,EAAEhB,EAAEL,GAEZU,EAAYH,EADZc,EAAIA,EAAEhB,GAIRgB,EAAEhB,EAAEiB,EAjQE,EAkQND,EAAEhB,EAAEA,EAAEiB,EAnQF,EAoQJhB,EAAWC,EAAMc,EAAEhB,EAAEA,IAI3BE,EAAKE,KAAKa,EAvQE,EAwURC,CAAUhB,EAAMc,GAChBR,EAAS1D,GAASkE,EAClBd,EAAK/D,QAGPgF,OAAOrE,OACCkE,EAAIR,EAAS1D,WACT,IAANkE,UACGR,EAAS1D,OAEVsE,EAjSZ,SAAwBT,EAAoB7D,OACtC2C,EAAwBkB,EAASE,QACjCpB,EAAK3C,QAAUA,SACC,OAAd2C,EAAKqB,KAjDE,GAkDXH,EAASE,KAAOpB,EAAKqB,KAjDZ,OAqDPF,EAAiCnB,MACrCA,EAAOA,EAAKqB,KAEI,OAATrB,GAAe,IAChBA,EAAK3C,QAAUA,SACjB8D,EAASE,KAAOrB,EAAKqB,KA1Dd,EA6DTF,EAAWnB,EACXA,EAAOA,EAAKqB,MAgRaO,CAAeL,EAAGlE,WAClB,IAAnBsE,MA/UG,IAgVHA,SACFJ,EAAEtB,KAAOsB,EAAEH,KAAKnB,KAChBF,EAAUwB,GACVlB,EAAYkB,QACZd,EAAK/D,WAMH4D,EAFAI,EAAIa,EACJM,EAAiBnB,EAAEc,EAGnBD,EAAErB,IAAMC,GACVG,EAAIiB,EAAEnB,EACNS,EAAYJ,EAAMc,EAAGA,EAAEnB,IACdmB,EAAEnB,IAAMD,GACjBG,EAAIiB,EAAErB,EACNW,EAAYJ,EAAMc,EAAGA,EAAErB,KAGvB2B,GADAnB,EA9IR,SAAqBJ,QACZA,EAAEJ,IAAMC,GAAWG,EAAIA,EAAEJ,SACzBI,EA4IGwB,CAAYP,EAAEnB,IACCoB,EACnBlB,EAAII,EAAEN,EAEFM,EAAEH,IAAMgB,EACVjB,EAAEC,EAAIG,GAENG,EAAYJ,EAAMC,EAAGA,EAAEN,GACvBM,EAAEN,EAAImB,EAAEnB,EACRM,EAAEN,EAAEG,EAAIG,GAGVG,EAAYJ,EAAMc,EAAGb,GACrBA,EAAER,EAAIqB,EAAErB,EACRQ,EAAER,EAAEK,EAAIG,EACRA,EAAEc,EAAID,EAAEC,GAGVzB,EAAUO,GACVD,EAAYC,GA1XJ,IA4XJuB,GAnOV,SAAmBpB,EAAYH,WACzByB,EAEGzB,IAAMH,GA5JD,IA4JcG,EAAEkB,GACtBlB,IAAMA,EAAEC,EAAEL,GA9JN,KA+JN6B,EAAIzB,EAAEC,EAAEH,GAEFoB,IACJO,EAAEP,EAjKI,EAkKNlB,EAAEC,EAAEiB,EAnKA,EAoKJhB,EAAWC,EAAMH,EAAEC,GACnBwB,EAAIzB,EAAEC,EAAEH,GApKF,IAuKJ2B,EAAE7B,EAAEsB,GAvKA,IAuKeO,EAAE3B,EAAEoB,GACzBO,EAAEP,EAzKE,EA0KJlB,EAAIA,EAAEC,IAzKA,IA2KFwB,EAAE3B,EAAEoB,IACNO,EAAE7B,EAAEsB,EA5KA,EA6KJO,EAAEP,EA9KA,EA+KFZ,EAAYH,EAAMsB,GAClBA,EAAIzB,EAAEC,EAAEH,GAGV2B,EAAEP,EAAIlB,EAAEC,EAAEiB,EACVlB,EAAEC,EAAEiB,EAnLE,EAoLNO,EAAE3B,EAAEoB,EApLE,EAqLNhB,EAAWC,EAAMH,EAAEC,GACnBD,EAAIG,EAAKE,QAvLL,KA0LNoB,EAAIzB,EAAEC,EAAEL,GAEFsB,IACJO,EAAEP,EA5LI,EA6LNlB,EAAEC,EAAEiB,EA9LA,EA+LJZ,EAAYH,EAAMH,EAAEC,GACpBwB,EAAIzB,EAAEC,EAAEL,GA/LF,IAkMJ6B,EAAE3B,EAAEoB,GAlMA,IAkMeO,EAAE7B,EAAEsB,GACzBO,EAAEP,EApME,EAqMJlB,EAAIA,EAAEC,IApMA,IAsMFwB,EAAE7B,EAAEsB,IACNO,EAAE3B,EAAEoB,EAvMA,EAwMJO,EAAEP,EAzMA,EA0MFhB,EAAWC,EAAMsB,GACjBA,EAAIzB,EAAEC,EAAEL,GAGV6B,EAAEP,EAAIlB,EAAEC,EAAEiB,EACVlB,EAAEC,EAAEiB,EA9ME,EA+MNO,EAAE7B,EAAEsB,EA/ME,EAgNNZ,EAAYH,EAAMH,EAAEC,GACpBD,EAAIG,EAAKE,OAKfL,EAAEkB,EAtNU,EA4XsBQ,CAAUvB,EAAMH,GAC9CG,EAAK/D,UAGPuF,OAAOhB,EAAKhB,EAAMiC,WACVC,EAAQ,CAAC1B,EAAKE,MACI,IAAjBwB,EAAM9F,QAAc,KACnB2D,EAAOmC,EAAMC,SACfpC,IAASG,GAAac,GAAMjB,EAAK7F,MACjC6F,EAAKE,IAAMC,GAAWgC,EAAMtE,KAAKmC,EAAKE,GACtCF,EAAKI,IAAMD,GAAWgC,EAAMtE,KAAKmC,EAAKI,GACtCJ,EAAKiB,KAAOhB,GAAQD,EAAKC,MAAQgB,WAC/BoB,EAAwBrC,EAAKoB,KACjB,OAATiB,GACDA,EAAKpC,KAAQgB,GAAKiB,EAASG,EAAKhF,MAAO2C,EAAKiB,KAChDoB,EAAOA,EAAKhB,yBAOXZ,EAAK/D,OCvYX,SAAS4F,IAOdnD,OANAzB,MACEA,EADFpB,YAEEA,EAAc,IAFhBiG,aAGEA,EAAe,EAHjBhG,YAIEA,cAEF4C,IAAAA,EAA6BC,QAEvBoD,EAAiB,SACdC,EAAqBC,GAAuBC,EACjDjF,EACApB,EACAiG,EACAhG,UAEKqG,EACLF,EACAD,EACAF,IAGEM,EAAgBjJ,SACQoD,IAA1B6F,EAAc/I,UAChB+I,EAAc/I,QAAU0I,SAEpBM,EAAWlJ,EAAauF,GACxB4D,EAAO,CAACrF,EAAOpB,EAAaiG,EAAchG,GAC1CyG,EAAWpJ,EAAamJ,GACxBE,GAAeF,EAAKG,MAAM,CAACC,EAAMtE,IAAMmE,EAASlJ,QAAQ+E,KAAOsE,MAajEF,IAAgB9D,EAAK+D,MAAM,CAACC,EAAMtE,IAAMiE,EAAShJ,QAAQ+E,KAAOsE,GAAO,KACnEC,EAAiBP,EAAc/I,QAC/BW,EAAa+H,OACnBM,EAAShJ,QAAUqF,EACnB6D,EAASlJ,QAAUiJ,EAEfE,UACII,EAAYD,EAAe1G,OACxBW,EAAQ,EAAWgG,EAARhG,EAAmBA,IAAS,KACxCiG,EAAMF,EAAeG,IAAIlG,GAC/B5C,EAAW+I,IAAInG,OAAe,IAARiG,EAAiBA,EAAI1H,OAAS,GAIxDiH,EAAc/I,QAAUW,SAGnBoI,EAAc/I,QC3DhB,SAAS2J,EACdhJ,EACAiJ,UAEMC,MACJA,EAAQ,MADJC,QAEJA,EAA4B,oBAAXC,QAA0BA,OAFvCvK,OAGJA,EAAS,EAHLsC,OAIJA,GAA2B,oBAAXiI,OAAyBA,OAAOC,YAAc,IAC5DJ,EACEK,EAAgB7G,EAAU,CAC9BzC,WAAAA,EACAmJ,QAAAA,EACAD,MAAAA,EACArK,OAAAA,EACAsC,OAAAA,IAEIoI,EAAYpK,EAAa,SACvBqK,EAAgBF,EAAcjK,QAAQ8J,eACrCK,GAAiB,YAAaA,EACjCA,EAAcnK,QACdmK,IACHnK,SACIoK,EAAOC,GAAYvK,EACxB,CACEsK,EAKAE,WAMMC,EAAY,CAChBzG,SAAUsG,EAAMtG,SAChBP,MAAO6G,EAAM7G,MACbiH,QAASJ,EAAMI,YAIG,kBAAhBF,EAAOG,WACF,CACL3G,SAAUmG,EAAcjK,QAAQW,WAAW8I,cAAIa,EAAOI,sBAAU,GAChEnH,MAAO+G,EAAOI,MACdF,aAAS,GAEN,GAAoB,gBAAhBF,EAAOG,KAChBF,EAAUzG,SAAWwG,EAAOI,WACvB,GAAoB,eAAhBJ,EAAOG,KAChBF,EAAUC,QAAUF,EAAOI,WACtB,GAAoB,UAAhBJ,EAAOG,YACTE,UAGFJ,GAETI,IAEIC,EAAoBC,EAAoBR,EAAU,IAIxDS,EAASZ,IAAuB,SAAU,SACnCE,EAAMtG,UAAYsG,EAAM7G,MAAO,KAC5BO,EAAWmG,EAAcjK,QAAQW,WAAW8I,IAAIW,EAAM7G,OAExDO,GACFuG,EAAS,CAACI,KAAM,cAAeC,MAAO5G,WAOtCiH,OACY,IAAhBX,EAAM7G,kBACN0G,EAAcjK,QAAQW,WAAW8I,IAAIW,EAAM7G,2BAA3CyH,EAAmDvH,YAErD3D,EAAgB,SACRmL,EAASf,OACVe,OACCnJ,OAACA,EAAD+H,MAASA,EAATrK,OAAgBA,EAAhBmB,WAAwBA,GAAcsJ,EAAcjK,WAEtDoK,EAAMtG,SAAU,KACdnE,EAAYyK,EAAMtG,SAASL,IAEjB,WAAVoG,EACFlK,EAAYA,EAAYmC,EAASsI,EAAMtG,SAAShC,OAC7B,WAAV+H,IACTlK,IAAcmC,EAASsI,EAAMtG,SAAShC,QAAU,GAGlDmJ,EAAOC,SAAS,EAAG9K,KAAKC,IAAI,EAAIV,GAAaH,QAIzC2L,EAAiB,EACfC,EAAUC,WACd,KAAOF,GAAkBd,EAAS,CAACI,KAAM,UACzC,WAEK,KACLU,EAAiB,EACjBG,aAAaF,IAEV,QAAoB,IAAhBhB,EAAM7G,MAAkB,KAE7BgI,EACD5K,EAAWkC,iBAAmBlC,EAAWiC,OAAUwH,EAAM7G,MACxD6G,EAAMI,UACRe,EAAenL,KAAKC,IAAIkL,EAAcnB,EAAMI,QAAU1I,IACxDmJ,EAAOC,SAAS,EAAGK,GACnBX,EAAkB,CAACH,KAAM,aAAcC,MAAOa,OAE/C,CAACR,EAAYX,EAAOH,EAAeC,EAAWU,IAE1C9K,EAAcyD,IACnB8G,EAAS,CAACI,KAAM,gBAAiBC,MAAOnH,MACvCvD,QCrHE,SAASwL,EAAcvG,OACtB3D,EAAexB,EAAiC,MAChD2L,EAAaC,EAAc,CAC/BC,aAAc1G,EAAM2G,SACpBC,cAAe5G,EAAM6G,YAEjBC,EAAe5G,EAAqB7D,EAAcmK,GAClDO,EAAY9H,OAAOC,OACvB,CACE3E,OAAQuM,EAAavM,OACrBoE,MAAOmI,EAAanI,OAAS6H,EAAW,GACxC3J,OAAQ2J,EAAW,GACnBnK,aAAAA,GAEF2D,GAEF+G,EAAUrL,WAAa6H,EAAcwD,GACrCA,EAAUpL,eAAiBkF,EAAkBkG,EAAUrL,gBACjDsL,EAAgBtC,EAAiBqC,EAAUrL,WAAY,CAC3DmB,OAAQkK,EAAUlK,OAClBtC,OAAQuM,EAAavM,OACrBqK,MACiC,iBAAxB5E,EAAMgH,cACThH,EAAMgH,cAAcpC,WACpB,IAEFtG,EACJ0B,EAAMgH,gBAC0B,iBAAxBhH,EAAMgH,cACVhH,EAAMgH,cACNhH,EAAMgH,cAAc1I,cAE1BzD,EAAgB,UACA,IAAVyD,GAAkB0I,EAAc1I,IACnC,CAACA,EAAO0I,IAEJjI,GAAoBgB,EAAiBgH,GC7CvC,SAASE,EAAWjH,UAEvBjB,GAACwH,KACCpK,KAAK,OACLqH,aAAcxD,EAAMkH,UACpB1J,YAAa,EACbD,YAAa,GACTyC,ICAH,SAASmH,EACdC,EACAzC,YAAAA,IAAAA,EAA0CpJ,QAEpC8L,aACJA,EADIC,iBAEJA,EAAmB,GAFfC,UAGJA,EAAY,GAHRC,WAIJA,EAAa,KACX7C,EACE8C,EAAsBtJ,EAAUiJ,GAChCM,EAAqBvJ,EAAUkJ,UAE9BxM,EACL,CAACoC,EAAYxB,EAAWG,aAChB+L,EA+BZ,SACEN,EAGAC,EACA1L,EACA4L,EACAvK,EACAxB,YAPA4L,IAAAA,EAEoBO,aACpBN,IAAAA,EAAuE,aAEvEE,IAAAA,EAA2D,aAKvDK,EACFC,EAFIH,EAA2B,GAG/BrJ,EAAQrB,EAGMxB,GAAT6C,EAAoBA,IACpB+I,EAAa/I,EAAO1C,QAGM,IAApBiM,QAAiD,IAAnBC,IACvCH,EAAe7I,KAAK+I,EAAiBC,GACrCD,EAAkBC,OAAiB,IAJnCA,EAAiBxJ,OACO,IAApBuJ,IAA4BA,EAAkBvJ,YAS9B,IAApBuJ,QAAiD,IAAnBC,EAA2B,KACrDC,EAAqB5M,KAAKiE,IAC9BjE,KAAKC,IAAI0M,EAAgBD,EAAkBP,EAAmB,GAC9DE,EAAa,OAIVlJ,EAAQwJ,EAAiB,EAAYC,GAATzJ,IAC1B+I,EAAa/I,EAAO1C,GADmC0C,IAE1DwJ,EAAiBxJ,EAMrBqJ,EAAe7I,KAAK+I,EAAiBC,MAMnCH,EAAerK,eACb0K,EAAqBL,EAAe,GAClCM,EAAoBN,EAAe,GAGML,EAA7CW,EAAoBD,EAAqB,GACzCA,EAAqB,GACrB,KACM1J,EAAQ0J,EAAqB,KAE9BX,EAAa/I,EAAO1C,SACvB+L,EAAe,GAAKK,EAAqB1J,SAOxCqJ,EAlGoBO,CACrBR,EAAmB3M,QACnBuM,EACA1L,EACA4L,EACArM,KAAKC,IAAI,EAAG6B,EAAasK,GACzBpM,KAAKiE,IAAIoI,EAAa,GAAI/L,GAAa,GAAK8L,IAKrCzH,EAAI,EAAGA,EAAI6H,EAAerK,OAAS,IAAKwC,EAC/C2H,EAAoB1M,QAClB4M,EAAe7H,GACf6H,IAAiB7H,GACjBlE,IAGN,CACE4L,EACAF,EACAC,EACAE,EACAC,ooBCrDC,IAAMS,EAA0C,IAAIC,QXOrD7M,EAAW,OCiNbkE,EAAe,IAyJbN,EAAsBkJ,EAC1B,CAACC,EAAW,GAAIF,QAASE,GACzB,CAACvL,EAAiBuB,EAAOG,EAAMlB,IAC7BwB,EAAChC,GAAgBuB,MAAOA,EAAOG,KAAMA,EAAME,MAAOpB,KAIhDoC,EAAoB4I,EACxB,CAAC3N,EAAkC8C,MACjCmB,SAAU,WACVF,MAAO,OACP6J,SAAU,OACV3L,OAAQ1B,KAAKmE,KAAK5B,GAClB+K,UAAWtN,KAAKmE,KAAK5B,GACrBgL,WAAY9N,EAAc,gBAAa,EACvC+N,cAAe/N,EAAc,YAAS,KAIpCgO,EAAO,CAACC,EAAkBC,IAC9BD,EAAK,KAAOC,EAAM,IAAMD,EAAK,KAAOC,EAAM,GAEtClJ,EAAkB2I,EACtB,CAAC7I,EAAgBqJ,IAAc9J,OAAOC,OAAO,GAAIQ,EAAgBqJ,GAEjEH,GASIpJ,EAAgB+I,EACnB5J,KACCA,MAAAA,EACAqK,QAAS,IACTC,WAAY,SACZpK,SAAU,WACVD,YAAa,kBAEf,CAACiK,EAAMC,IAAUD,EAAK,KAAOC,EAAM,IAG/B1L,EAAemL,EACnB,CACE7M,EACAC,IACI2C,GAAmBmC,IACZ,OAAPA,IACA9E,IACFA,EAAeuN,QAAQzI,GACvB0H,EAAc1D,IAAIhE,EAAInC,SAEM,IAA1B5C,EAAW8I,IAAIlG,IAAmB5C,EAAW+I,IAAInG,EAAOmC,EAAG0I,gBAGjEP,GE9WIvI,EAAe,GC/BRU,EAAuBsH,EAClC,CAACD,SAGD,CAAC1M,EAAwB0N,SACjBC,EAAgBC,EAAUC,YACxBC,EAAoB,GACtB1J,EAAI,EAEDA,EAAIyJ,EAAQjM,OAAQwC,IAAK,KACxB2J,EAAQF,EAAQzJ,GAChBjD,EAAU4M,EAAMzD,OAAuBmD,gBAEzCtM,EAAS,EAAG,KACRyB,EAAQ6J,EAAc3D,IAAIiF,EAAMzD,gBAExB,IAAV1H,EAAkB,KACdO,EAAWnD,EAAW8I,IAAIlG,QAEf,IAAbO,GAAuBhC,IAAWgC,EAAShC,QAC7C2M,EAAQ1K,KAAKR,EAAOzB,KAKxB2M,EAAQlM,OAAS,IAGnB5B,EAAWgO,OAAOF,GAClBJ,EAAQI,MAING,EAAK,IAAIC,EAAeP,GAIxBvI,EAAa6I,EAAG7I,WAAW+I,KAAKF,UACtCA,EAAG7I,WAAa,KACdA,IACAuI,EAAcS,UAGTH,ICDLvI,EAAsB,CAC1Bc,IAAK,EACL9G,IAAK,EACL8F,KAAM,EACNuB,EAzEU,EA2EVjB,OAAGvD,EAEHoD,OAAGpD,EAEHkD,OAAGlD,EAEHoE,UAAMpE,GAGRmD,EAAUI,EAAIJ,EACdA,EAAUD,EAAIC,EACdA,EAAUC,EAAID,MCqBDyC,EAAmB,SAC9BrG,EACAD,EACAiG,YAAAA,IAAAA,EAAe,WAITuG,EAAehI,IAGfiI,EAA0B,IAAIC,MAAMzM,GAEpC5B,EAA0B,GAE1BsO,EAA0B,IAAID,MAAMzM,GAEjCsC,EAAI,EAAOtC,EAAJsC,EAAiBA,IAC/BkK,EAAclK,GAAK,EACnBoK,EAAYpK,GAAK,SAGZ,CACLtC,YAAAA,EACAD,YAAAA,EACAkH,IAAK,SAACnG,EAAOzB,YAAAA,IAAAA,EAAS,WAChBsN,EAAS,EAGJrK,EAAI,EAAGA,EAAIkK,EAAc1M,OAAQwC,IACpCkK,EAAclK,GAAKkK,EAAcG,KAASA,EAASrK,OAGnDtB,EAAMwL,EAAcG,IAAW,EACrCH,EAAcG,GAAU3L,EAAM3B,EAAS2G,EACvC0G,EAAYC,GAAQrL,KAAKR,GACzB1C,EAAM0C,GAAS,CACbC,KAAM4L,GAAU5M,EAAciG,GAC9BhF,IAAAA,EACA3B,OAAAA,EACAsN,OAAAA,GAEFJ,EAAa9H,OAAOzD,EAAKA,EAAM3B,EAAQyB,IAEzCkG,IAAMlG,GAAU1C,EAAM0C,GAGtBoL,OAASF,YACDY,EAAoB,IAAIH,MAAMzM,GAChCsC,EAAI,EACNuK,EAAI,EAKCvK,EAAI0J,EAAQlM,OAAS,EAAGwC,IAAK,KAC5BxB,EAAQkL,EAAQ1J,GAChBsE,EAAOxI,EAAM0C,GACnB8F,EAAKvH,OAAS2M,IAAU1J,GACxBiK,EAAapH,OAAOrE,GACpByL,EAAa9H,OAAOmC,EAAK5F,IAAK4F,EAAK5F,IAAM4F,EAAKvH,OAAQyB,GACtD8L,EAAQhG,EAAK+F,aACc,IAAzBC,EAAQhG,EAAK+F,QACT7L,EACAnD,KAAKiE,IAAId,EAAO8L,EAAQhG,EAAK+F,aAGhCrK,EAAI,EAAGA,EAAIsK,EAAQ9M,OAAQwC,YAEX,IAAfsK,EAAQtK,QACNwK,EAAgBJ,EAAYpK,GAG5B7C,EAAasN,EAAaD,EAAeF,EAAQtK,IACjDxB,EAAQ4L,EAAYpK,GAAG7C,GACvBuN,EAAY5O,EAAM0C,OACxB0L,EAAclK,GAAK0K,EAAUhM,IAAMgM,EAAU3N,OAAS2G,EAEjD6G,EAAIpN,EAAa,EAAGoN,EAAIC,EAAchN,OAAQ+M,IAAK,KAChD/L,EAAQgM,EAAcD,GACtBjG,EAAOxI,EAAM0C,GACnB8F,EAAK5F,IAAMwL,EAAclK,GACzBkK,EAAclK,GAAKsE,EAAK5F,IAAM4F,EAAKvH,OAAS2G,EAC5CuG,EAAapH,OAAOrE,GACpByL,EAAa9H,OAAOmC,EAAK5F,IAAK4F,EAAK5F,IAAM4F,EAAKvH,OAAQyB,MAK5Db,MAAO,CAACgN,EAAIC,EAAIC,IACdZ,EAAa7G,OAAOuH,EAAIC,EAAI,CAACpM,EAAOE,IAClCmM,EAAerM,EAAO1C,EAAM0C,GAAOC,KAAMC,IAE7Cd,eAAgB,CAACL,EAAWuN,SACpBC,EAAgB1P,KAAKC,IAAI,EAAGD,KAAKC,IAAI0P,MAAM,KAAMd,WAEhD3M,IAAc0M,EAAapM,KAC9BkN,EACAA,EACE1P,KAAKmE,MAAMjC,EAAY0M,EAAapM,MAAQH,GAC1CoN,GAEVhN,eAAgB,IACVoM,EAAc1M,OAAS,EAAUnC,KAAKiE,IAAI0L,MAAM,KAAMd,GACnDA,EAAc,IAAM,EAE7BrM,KAAI,IACKoM,EAAapM,OA4EpB4M,EAAe,CAACQ,EAAapJ,aAC7BqJ,EAAI,EACJC,EAAIF,EAAEzN,OAAS,EAEP2N,GAALD,GAAQ,KACPE,EAAKF,EAAIC,IAAO,EAChB1J,EAAIwJ,EAAEG,MACR3J,IAAMI,EAAG,OAAOuJ,EACX3J,EAAKI,EACTsJ,EAAIC,EAAI,EADIF,EAAIE,EAAI,SAInB,GAGJtH,EAAa,SACjBjF,EACAwM,EACAC,EACA5N,mBAHAmB,IAAAA,EAAQ,YACRwM,IAAAA,EAAe,YACfC,IAAAA,EAAS,GAGT5N,EAAcA,GAAerC,KAAKkQ,MAAM1M,GAASwM,EAAeC,KAAY,EAIrE,CAHajQ,KAAKkQ,OACtB1M,EAAQyM,GAAU5N,EAAc,IAAMA,GAEpBA,IAGjB6C,GAAe,GCvLfqF,GAAe,CACnBpH,WAAO,EACPO,cAAU,EACV0G,aAAS,aGTLqC,GAAsB,CAAOtJ,EAAe1C,SAC/B,IAAjBA,EAAM0C,GAmCF/C,GAAW"}